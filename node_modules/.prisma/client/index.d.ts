
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model categories
 */

export type categories = {
  CategoryID: number
  CategoryName: string | null
  Description: string | null
  Picture: Buffer | null
}

/**
 * Model customercustomerdemo
 */

export type customercustomerdemo = {
  CustomerID: string
  CustomerTypeID: string | null
}

/**
 * Model customerdemographics
 */

export type customerdemographics = {
  CustomerTypeID: string
  CustomerDesc: string | null
}

/**
 * Model customers
 */

export type customers = {
  CustomerID: string
  CompanyName: string
  ContactName: string
  ContactTitle: string
  Address: string
  City: string
  Region: string
  PostalCode: string
  Country: string
  Phone: string
  Fax: string
}

/**
 * Model employees
 */

export type employees = {
  EmployeeID: number
  LastName: string | null
  FirstName: string | null
  Title: string | null
  TitleOfCourtesy: string | null
  BirthDate: Date | null
  HireDate: Date | null
  Address: string | null
  City: string | null
  Region: string | null
  PostalCode: string | null
  Country: string | null
  HomePhone: string | null
  Extension: string | null
  Photo: Buffer | null
  Notes: string | null
  ReportsTo: number | null
  PhotoPath: string | null
}

/**
 * Model employeeterritories
 */

export type employeeterritories = {
  EmployeeID: number
  TerritoryID: string | null
}

/**
 * Model orderdetails
 */

export type orderdetails = {
  OrderID: number
  ProductID: number | null
  UnitPrice: Prisma.Decimal | null
  Quantity: number | null
  Discount: number | null
}

/**
 * Model orders
 */

export type orders = {
  OrderID: number
  CustomerID: string
  EmployeeID: number | null
  OrderDate: Date | null
  RequiredDate: Date | null
  ShippedDate: Date | null
  ShipVia: number | null
  Freight: Prisma.Decimal | null
  ShipName: string | null
  ShipAddress: string | null
  ShipCity: string | null
  ShipRegion: string | null
  ShipPostalCode: string | null
  ShipCountry: string | null
}

/**
 * Model products
 */

export type products = {
  ProductID: number
  ProductName: string | null
  SupplierID: number | null
  CategoryID: number | null
  QuantityPerUnit: string | null
  UnitPrice: Prisma.Decimal | null
  UnitsInStock: number | null
  UnitsOnOrder: number | null
  ReorderLevel: number | null
  Discontinued: string | null
}

/**
 * Model regions
 */

export type regions = {
  RegionID: number
  RegionDescription: string | null
}

/**
 * Model shippers
 */

export type shippers = {
  ShipperID: number
  CompanyName: string | null
  Phone: string | null
}

/**
 * Model suppliers
 */

export type suppliers = {
  SupplierID: number
  CompanyName: string | null
  ContactName: string | null
  ContactTitle: string | null
  Address: string | null
  City: string | null
  Region: string | null
  PostalCode: string | null
  Country: string | null
  Phone: string | null
  Fax: string | null
  HomePage: string | null
}

/**
 * Model territories
 */

export type territories = {
  TerritoryID: string
  TerritoryDescription: string | null
  RegionID: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.categories.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.categories.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<GlobalReject>;

  /**
   * `prisma.customercustomerdemo`: Exposes CRUD operations for the **customercustomerdemo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customercustomerdemos
    * const customercustomerdemos = await prisma.customercustomerdemo.findMany()
    * ```
    */
  get customercustomerdemo(): Prisma.customercustomerdemoDelegate<GlobalReject>;

  /**
   * `prisma.customerdemographics`: Exposes CRUD operations for the **customerdemographics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customerdemographics
    * const customerdemographics = await prisma.customerdemographics.findMany()
    * ```
    */
  get customerdemographics(): Prisma.customerdemographicsDelegate<GlobalReject>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<GlobalReject>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.employeesDelegate<GlobalReject>;

  /**
   * `prisma.employeeterritories`: Exposes CRUD operations for the **employeeterritories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employeeterritories
    * const employeeterritories = await prisma.employeeterritories.findMany()
    * ```
    */
  get employeeterritories(): Prisma.employeeterritoriesDelegate<GlobalReject>;

  /**
   * `prisma.orderdetails`: Exposes CRUD operations for the **orderdetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderdetails
    * const orderdetails = await prisma.orderdetails.findMany()
    * ```
    */
  get orderdetails(): Prisma.orderdetailsDelegate<GlobalReject>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<GlobalReject>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<GlobalReject>;

  /**
   * `prisma.regions`: Exposes CRUD operations for the **regions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.regions.findMany()
    * ```
    */
  get regions(): Prisma.regionsDelegate<GlobalReject>;

  /**
   * `prisma.shippers`: Exposes CRUD operations for the **shippers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shippers
    * const shippers = await prisma.shippers.findMany()
    * ```
    */
  get shippers(): Prisma.shippersDelegate<GlobalReject>;

  /**
   * `prisma.suppliers`: Exposes CRUD operations for the **suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.suppliers.findMany()
    * ```
    */
  get suppliers(): Prisma.suppliersDelegate<GlobalReject>;

  /**
   * `prisma.territories`: Exposes CRUD operations for the **territories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Territories
    * const territories = await prisma.territories.findMany()
    * ```
    */
  get territories(): Prisma.territoriesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.19.0
   * Query Engine version: c1455d0b443d66b0d9db9bcb1bb9ee0d5bbc511d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    categories: 'categories',
    customercustomerdemo: 'customercustomerdemo',
    customerdemographics: 'customerdemographics',
    customers: 'customers',
    employees: 'employees',
    employeeterritories: 'employeeterritories',
    orderdetails: 'orderdetails',
    orders: 'orders',
    products: 'products',
    regions: 'regions',
    shippers: 'shippers',
    suppliers: 'suppliers',
    territories: 'territories'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model categories
   */


  export type AggregateCategories = {
    count: CategoriesCountAggregateOutputType | null
    avg: CategoriesAvgAggregateOutputType | null
    sum: CategoriesSumAggregateOutputType | null
    min: CategoriesMinAggregateOutputType | null
    max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    CategoryID: number
  }

  export type CategoriesSumAggregateOutputType = {
    CategoryID: number
  }

  export type CategoriesMinAggregateOutputType = {
    CategoryID: number
    CategoryName: string | null
    Description: string | null
    Picture: Buffer | null
  }

  export type CategoriesMaxAggregateOutputType = {
    CategoryID: number
    CategoryName: string | null
    Description: string | null
    Picture: Buffer | null
  }

  export type CategoriesCountAggregateOutputType = {
    CategoryID: number
    CategoryName: number | null
    Description: number | null
    Picture: number | null
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    CategoryID?: true
  }

  export type CategoriesSumAggregateInputType = {
    CategoryID?: true
  }

  export type CategoriesMinAggregateInputType = {
    CategoryID?: true
    CategoryName?: true
    Description?: true
    Picture?: true
  }

  export type CategoriesMaxAggregateInputType = {
    CategoryID?: true
    CategoryName?: true
    Description?: true
    Picture?: true
  }

  export type CategoriesCountAggregateInputType = {
    CategoryID?: true
    CategoryName?: true
    Description?: true
    Picture?: true
    _all?: true
  }

  export type CategoriesAggregateArgs = {
    /**
     * Filter which categories to aggregate.
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
    [P in keyof T & keyof AggregateCategories]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }



  export type categoriesSelect = {
    CategoryID?: boolean
    CategoryName?: boolean
    Description?: boolean
    Picture?: boolean
    products_categoriesToproducts_CategoryID?: boolean | productsFindManyArgs
  }

  export type categoriesInclude = {
    products_categoriesToproducts_CategoryID?: boolean | productsFindManyArgs
  }

  export type categoriesGetPayload<
    S extends boolean | null | undefined | categoriesArgs,
    U = keyof S
      > = S extends true
        ? categories
    : S extends undefined
    ? never
    : S extends categoriesArgs | categoriesFindManyArgs
    ?'include' extends U
    ? categories  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products_categoriesToproducts_CategoryID'
        ? Array < productsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof categories ?categories [P]
  : 
          P extends 'products_categoriesToproducts_CategoryID'
        ? Array < productsGetPayload<S['select'][P]>>  : never
  } 
    : categories
  : categories


  type categoriesCountArgs = Merge<
    Omit<categoriesFindManyArgs, 'select' | 'include'> & {
      select?: CategoriesCountAggregateInputType | true
    }
  >

  export interface categoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categories'> extends True ? CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>> : CheckSelect<T, Prisma__categoriesClient<categories | null >, Prisma__categoriesClient<categoriesGetPayload<T> | null >>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categories'> extends True ? CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>> : CheckSelect<T, Prisma__categoriesClient<categories | null >, Prisma__categoriesClient<categoriesGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `CategoryID`
     * const categoriesWithCategoryIDOnly = await prisma.categories.findMany({ select: { CategoryID: true } })
     * 
    **/
    findMany<T extends categoriesFindManyArgs>(
      args?: SelectSubset<T, categoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<categories>>, PrismaPromise<Array<categoriesGetPayload<T>>>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
    **/
    create<T extends categoriesCreateArgs>(
      args: SelectSubset<T, categoriesCreateArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
    **/
    delete<T extends categoriesDeleteArgs>(
      args: SelectSubset<T, categoriesDeleteArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoriesUpdateArgs>(
      args: SelectSubset<T, categoriesUpdateArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoriesDeleteManyArgs>(
      args?: SelectSubset<T, categoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoriesUpdateManyArgs>(
      args: SelectSubset<T, categoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
    **/
    upsert<T extends categoriesUpsertArgs>(
      args: SelectSubset<T, categoriesUpsertArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): PrismaPromise<GetCategoriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products_categoriesToproducts_CategoryID<T extends productsFindManyArgs = {}>(args?: Subset<T, productsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<products>>, PrismaPromise<Array<productsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * Throw an Error if a categories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which categories to fetch.
    **/
    where: categoriesWhereUniqueInput
  }


  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * Throw an Error if a categories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which categories to fetch.
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
    **/
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }


  /**
   * categories findMany
   */
  export type categoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * Filter, which categories to fetch.
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }


  /**
   * categories create
   */
  export type categoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * The data needed to create a categories.
    **/
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }


  /**
   * categories update
   */
  export type categoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * The data needed to update a categories.
    **/
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
    **/
    where: categoriesWhereUniqueInput
  }


  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs = {
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    where?: categoriesWhereInput
  }


  /**
   * categories upsert
   */
  export type categoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * The filter to search for the categories to update in case it exists.
    **/
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
    **/
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }


  /**
   * categories delete
   */
  export type categoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
    /**
     * Filter which categories to delete.
    **/
    where: categoriesWhereUniqueInput
  }


  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs = {
    where?: categoriesWhereInput
  }


  /**
   * categories without action
   */
  export type categoriesArgs = {
    /**
     * Select specific fields to fetch from the categories
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoriesInclude | null
  }



  /**
   * Model customercustomerdemo
   */


  export type AggregateCustomercustomerdemo = {
    count: CustomercustomerdemoCountAggregateOutputType | null
    min: CustomercustomerdemoMinAggregateOutputType | null
    max: CustomercustomerdemoMaxAggregateOutputType | null
  }

  export type CustomercustomerdemoMinAggregateOutputType = {
    CustomerID: string | null
    CustomerTypeID: string | null
  }

  export type CustomercustomerdemoMaxAggregateOutputType = {
    CustomerID: string | null
    CustomerTypeID: string | null
  }

  export type CustomercustomerdemoCountAggregateOutputType = {
    CustomerID: number | null
    CustomerTypeID: number | null
    _all: number
  }


  export type CustomercustomerdemoMinAggregateInputType = {
    CustomerID?: true
    CustomerTypeID?: true
  }

  export type CustomercustomerdemoMaxAggregateInputType = {
    CustomerID?: true
    CustomerTypeID?: true
  }

  export type CustomercustomerdemoCountAggregateInputType = {
    CustomerID?: true
    CustomerTypeID?: true
    _all?: true
  }

  export type CustomercustomerdemoAggregateArgs = {
    /**
     * Filter which customercustomerdemo to aggregate.
    **/
    where?: customercustomerdemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customercustomerdemos to fetch.
    **/
    orderBy?: Enumerable<customercustomerdemoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: customercustomerdemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customercustomerdemos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customercustomerdemos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customercustomerdemos
    **/
    count?: true | CustomercustomerdemoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CustomercustomerdemoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CustomercustomerdemoMaxAggregateInputType
  }

  export type GetCustomercustomerdemoAggregateType<T extends CustomercustomerdemoAggregateArgs> = {
    [P in keyof T & keyof AggregateCustomercustomerdemo]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomercustomerdemo[P]>
      : GetScalarType<T[P], AggregateCustomercustomerdemo[P]>
  }



  export type customercustomerdemoSelect = {
    CustomerID?: boolean
    CustomerTypeID?: boolean
    customers?: boolean | customersArgs
    customerdemographics?: boolean | customerdemographicsArgs
  }

  export type customercustomerdemoInclude = {
    customers?: boolean | customersArgs
    customerdemographics?: boolean | customerdemographicsArgs
  }

  export type customercustomerdemoGetPayload<
    S extends boolean | null | undefined | customercustomerdemoArgs,
    U = keyof S
      > = S extends true
        ? customercustomerdemo
    : S extends undefined
    ? never
    : S extends customercustomerdemoArgs | customercustomerdemoFindManyArgs
    ?'include' extends U
    ? customercustomerdemo  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customers'
        ? customersGetPayload<S['include'][P]> :
        P extends 'customerdemographics'
        ? customerdemographicsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof customercustomerdemo ?customercustomerdemo [P]
  : 
          P extends 'customers'
        ? customersGetPayload<S['select'][P]> :
        P extends 'customerdemographics'
        ? customerdemographicsGetPayload<S['select'][P]> | null : never
  } 
    : customercustomerdemo
  : customercustomerdemo


  type customercustomerdemoCountArgs = Merge<
    Omit<customercustomerdemoFindManyArgs, 'select' | 'include'> & {
      select?: CustomercustomerdemoCountAggregateInputType | true
    }
  >

  export interface customercustomerdemoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customercustomerdemo that matches the filter.
     * @param {customercustomerdemoFindUniqueArgs} args - Arguments to find a Customercustomerdemo
     * @example
     * // Get one Customercustomerdemo
     * const customercustomerdemo = await prisma.customercustomerdemo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customercustomerdemoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, customercustomerdemoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'customercustomerdemo'> extends True ? CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>> : CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo | null >, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T> | null >>

    /**
     * Find the first Customercustomerdemo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customercustomerdemoFindFirstArgs} args - Arguments to find a Customercustomerdemo
     * @example
     * // Get one Customercustomerdemo
     * const customercustomerdemo = await prisma.customercustomerdemo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customercustomerdemoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, customercustomerdemoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'customercustomerdemo'> extends True ? CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>> : CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo | null >, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T> | null >>

    /**
     * Find zero or more Customercustomerdemos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customercustomerdemoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customercustomerdemos
     * const customercustomerdemos = await prisma.customercustomerdemo.findMany()
     * 
     * // Get first 10 Customercustomerdemos
     * const customercustomerdemos = await prisma.customercustomerdemo.findMany({ take: 10 })
     * 
     * // Only select the `CustomerID`
     * const customercustomerdemoWithCustomerIDOnly = await prisma.customercustomerdemo.findMany({ select: { CustomerID: true } })
     * 
    **/
    findMany<T extends customercustomerdemoFindManyArgs>(
      args?: SelectSubset<T, customercustomerdemoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<customercustomerdemo>>, PrismaPromise<Array<customercustomerdemoGetPayload<T>>>>

    /**
     * Create a Customercustomerdemo.
     * @param {customercustomerdemoCreateArgs} args - Arguments to create a Customercustomerdemo.
     * @example
     * // Create one Customercustomerdemo
     * const Customercustomerdemo = await prisma.customercustomerdemo.create({
     *   data: {
     *     // ... data to create a Customercustomerdemo
     *   }
     * })
     * 
    **/
    create<T extends customercustomerdemoCreateArgs>(
      args: SelectSubset<T, customercustomerdemoCreateArgs>
    ): CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>>

    /**
     * Delete a Customercustomerdemo.
     * @param {customercustomerdemoDeleteArgs} args - Arguments to delete one Customercustomerdemo.
     * @example
     * // Delete one Customercustomerdemo
     * const Customercustomerdemo = await prisma.customercustomerdemo.delete({
     *   where: {
     *     // ... filter to delete one Customercustomerdemo
     *   }
     * })
     * 
    **/
    delete<T extends customercustomerdemoDeleteArgs>(
      args: SelectSubset<T, customercustomerdemoDeleteArgs>
    ): CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>>

    /**
     * Update one Customercustomerdemo.
     * @param {customercustomerdemoUpdateArgs} args - Arguments to update one Customercustomerdemo.
     * @example
     * // Update one Customercustomerdemo
     * const customercustomerdemo = await prisma.customercustomerdemo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customercustomerdemoUpdateArgs>(
      args: SelectSubset<T, customercustomerdemoUpdateArgs>
    ): CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>>

    /**
     * Delete zero or more Customercustomerdemos.
     * @param {customercustomerdemoDeleteManyArgs} args - Arguments to filter Customercustomerdemos to delete.
     * @example
     * // Delete a few Customercustomerdemos
     * const { count } = await prisma.customercustomerdemo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customercustomerdemoDeleteManyArgs>(
      args?: SelectSubset<T, customercustomerdemoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customercustomerdemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customercustomerdemoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customercustomerdemos
     * const customercustomerdemo = await prisma.customercustomerdemo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customercustomerdemoUpdateManyArgs>(
      args: SelectSubset<T, customercustomerdemoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customercustomerdemo.
     * @param {customercustomerdemoUpsertArgs} args - Arguments to update or create a Customercustomerdemo.
     * @example
     * // Update or create a Customercustomerdemo
     * const customercustomerdemo = await prisma.customercustomerdemo.upsert({
     *   create: {
     *     // ... data to create a Customercustomerdemo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customercustomerdemo we want to update
     *   }
     * })
    **/
    upsert<T extends customercustomerdemoUpsertArgs>(
      args: SelectSubset<T, customercustomerdemoUpsertArgs>
    ): CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo>, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T>>>

    /**
     * Count the number of Customercustomerdemos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customercustomerdemoCountArgs} args - Arguments to filter Customercustomerdemos to count.
     * @example
     * // Count the number of Customercustomerdemos
     * const count = await prisma.customercustomerdemo.count({
     *   where: {
     *     // ... the filter for the Customercustomerdemos we want to count
     *   }
     * })
    **/
    count<T extends customercustomerdemoCountArgs>(
      args?: Subset<T, customercustomerdemoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomercustomerdemoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customercustomerdemo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomercustomerdemoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomercustomerdemoAggregateArgs>(args: Subset<T, CustomercustomerdemoAggregateArgs>): PrismaPromise<GetCustomercustomerdemoAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for customercustomerdemo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__customercustomerdemoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customers<T extends customersArgs = {}>(args?: Subset<T, customersArgs>): CheckSelect<T, Prisma__customersClient<customers | null >, Prisma__customersClient<customersGetPayload<T> | null >>;

    customerdemographics<T extends customerdemographicsArgs = {}>(args?: Subset<T, customerdemographicsArgs>): CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics | null >, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * customercustomerdemo findUnique
   */
  export type customercustomerdemoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * Throw an Error if a customercustomerdemo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customercustomerdemo to fetch.
    **/
    where: customercustomerdemoWhereUniqueInput
  }


  /**
   * customercustomerdemo findFirst
   */
  export type customercustomerdemoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * Throw an Error if a customercustomerdemo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customercustomerdemo to fetch.
    **/
    where?: customercustomerdemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customercustomerdemos to fetch.
    **/
    orderBy?: Enumerable<customercustomerdemoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customercustomerdemos.
    **/
    cursor?: customercustomerdemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customercustomerdemos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customercustomerdemos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customercustomerdemos.
    **/
    distinct?: Enumerable<CustomercustomerdemoScalarFieldEnum>
  }


  /**
   * customercustomerdemo findMany
   */
  export type customercustomerdemoFindManyArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * Filter, which customercustomerdemos to fetch.
    **/
    where?: customercustomerdemoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customercustomerdemos to fetch.
    **/
    orderBy?: Enumerable<customercustomerdemoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customercustomerdemos.
    **/
    cursor?: customercustomerdemoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customercustomerdemos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customercustomerdemos.
    **/
    skip?: number
    distinct?: Enumerable<CustomercustomerdemoScalarFieldEnum>
  }


  /**
   * customercustomerdemo create
   */
  export type customercustomerdemoCreateArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * The data needed to create a customercustomerdemo.
    **/
    data: XOR<customercustomerdemoCreateInput, customercustomerdemoUncheckedCreateInput>
  }


  /**
   * customercustomerdemo update
   */
  export type customercustomerdemoUpdateArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * The data needed to update a customercustomerdemo.
    **/
    data: XOR<customercustomerdemoUpdateInput, customercustomerdemoUncheckedUpdateInput>
    /**
     * Choose, which customercustomerdemo to update.
    **/
    where: customercustomerdemoWhereUniqueInput
  }


  /**
   * customercustomerdemo updateMany
   */
  export type customercustomerdemoUpdateManyArgs = {
    data: XOR<customercustomerdemoUpdateManyMutationInput, customercustomerdemoUncheckedUpdateManyInput>
    where?: customercustomerdemoWhereInput
  }


  /**
   * customercustomerdemo upsert
   */
  export type customercustomerdemoUpsertArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * The filter to search for the customercustomerdemo to update in case it exists.
    **/
    where: customercustomerdemoWhereUniqueInput
    /**
     * In case the customercustomerdemo found by the `where` argument doesn't exist, create a new customercustomerdemo with this data.
    **/
    create: XOR<customercustomerdemoCreateInput, customercustomerdemoUncheckedCreateInput>
    /**
     * In case the customercustomerdemo was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<customercustomerdemoUpdateInput, customercustomerdemoUncheckedUpdateInput>
  }


  /**
   * customercustomerdemo delete
   */
  export type customercustomerdemoDeleteArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
    /**
     * Filter which customercustomerdemo to delete.
    **/
    where: customercustomerdemoWhereUniqueInput
  }


  /**
   * customercustomerdemo deleteMany
   */
  export type customercustomerdemoDeleteManyArgs = {
    where?: customercustomerdemoWhereInput
  }


  /**
   * customercustomerdemo without action
   */
  export type customercustomerdemoArgs = {
    /**
     * Select specific fields to fetch from the customercustomerdemo
    **/
    select?: customercustomerdemoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customercustomerdemoInclude | null
  }



  /**
   * Model customerdemographics
   */


  export type AggregateCustomerdemographics = {
    count: CustomerdemographicsCountAggregateOutputType | null
    min: CustomerdemographicsMinAggregateOutputType | null
    max: CustomerdemographicsMaxAggregateOutputType | null
  }

  export type CustomerdemographicsMinAggregateOutputType = {
    CustomerTypeID: string | null
    CustomerDesc: string | null
  }

  export type CustomerdemographicsMaxAggregateOutputType = {
    CustomerTypeID: string | null
    CustomerDesc: string | null
  }

  export type CustomerdemographicsCountAggregateOutputType = {
    CustomerTypeID: number | null
    CustomerDesc: number | null
    _all: number
  }


  export type CustomerdemographicsMinAggregateInputType = {
    CustomerTypeID?: true
    CustomerDesc?: true
  }

  export type CustomerdemographicsMaxAggregateInputType = {
    CustomerTypeID?: true
    CustomerDesc?: true
  }

  export type CustomerdemographicsCountAggregateInputType = {
    CustomerTypeID?: true
    CustomerDesc?: true
    _all?: true
  }

  export type CustomerdemographicsAggregateArgs = {
    /**
     * Filter which customerdemographics to aggregate.
    **/
    where?: customerdemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdemographics to fetch.
    **/
    orderBy?: Enumerable<customerdemographicsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: customerdemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdemographics from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdemographics.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerdemographics
    **/
    count?: true | CustomerdemographicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CustomerdemographicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CustomerdemographicsMaxAggregateInputType
  }

  export type GetCustomerdemographicsAggregateType<T extends CustomerdemographicsAggregateArgs> = {
    [P in keyof T & keyof AggregateCustomerdemographics]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerdemographics[P]>
      : GetScalarType<T[P], AggregateCustomerdemographics[P]>
  }



  export type customerdemographicsSelect = {
    CustomerTypeID?: boolean
    CustomerDesc?: boolean
    customercustomerdemo?: boolean | customercustomerdemoFindManyArgs
  }

  export type customerdemographicsInclude = {
    customercustomerdemo?: boolean | customercustomerdemoFindManyArgs
  }

  export type customerdemographicsGetPayload<
    S extends boolean | null | undefined | customerdemographicsArgs,
    U = keyof S
      > = S extends true
        ? customerdemographics
    : S extends undefined
    ? never
    : S extends customerdemographicsArgs | customerdemographicsFindManyArgs
    ?'include' extends U
    ? customerdemographics  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customercustomerdemo'
        ? Array < customercustomerdemoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof customerdemographics ?customerdemographics [P]
  : 
          P extends 'customercustomerdemo'
        ? Array < customercustomerdemoGetPayload<S['select'][P]>>  : never
  } 
    : customerdemographics
  : customerdemographics


  type customerdemographicsCountArgs = Merge<
    Omit<customerdemographicsFindManyArgs, 'select' | 'include'> & {
      select?: CustomerdemographicsCountAggregateInputType | true
    }
  >

  export interface customerdemographicsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customerdemographics that matches the filter.
     * @param {customerdemographicsFindUniqueArgs} args - Arguments to find a Customerdemographics
     * @example
     * // Get one Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerdemographicsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, customerdemographicsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'customerdemographics'> extends True ? CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>> : CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics | null >, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T> | null >>

    /**
     * Find the first Customerdemographics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdemographicsFindFirstArgs} args - Arguments to find a Customerdemographics
     * @example
     * // Get one Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerdemographicsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, customerdemographicsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'customerdemographics'> extends True ? CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>> : CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics | null >, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T> | null >>

    /**
     * Find zero or more Customerdemographics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdemographicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.findMany()
     * 
     * // Get first 10 Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.findMany({ take: 10 })
     * 
     * // Only select the `CustomerTypeID`
     * const customerdemographicsWithCustomerTypeIDOnly = await prisma.customerdemographics.findMany({ select: { CustomerTypeID: true } })
     * 
    **/
    findMany<T extends customerdemographicsFindManyArgs>(
      args?: SelectSubset<T, customerdemographicsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<customerdemographics>>, PrismaPromise<Array<customerdemographicsGetPayload<T>>>>

    /**
     * Create a Customerdemographics.
     * @param {customerdemographicsCreateArgs} args - Arguments to create a Customerdemographics.
     * @example
     * // Create one Customerdemographics
     * const Customerdemographics = await prisma.customerdemographics.create({
     *   data: {
     *     // ... data to create a Customerdemographics
     *   }
     * })
     * 
    **/
    create<T extends customerdemographicsCreateArgs>(
      args: SelectSubset<T, customerdemographicsCreateArgs>
    ): CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>>

    /**
     * Delete a Customerdemographics.
     * @param {customerdemographicsDeleteArgs} args - Arguments to delete one Customerdemographics.
     * @example
     * // Delete one Customerdemographics
     * const Customerdemographics = await prisma.customerdemographics.delete({
     *   where: {
     *     // ... filter to delete one Customerdemographics
     *   }
     * })
     * 
    **/
    delete<T extends customerdemographicsDeleteArgs>(
      args: SelectSubset<T, customerdemographicsDeleteArgs>
    ): CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>>

    /**
     * Update one Customerdemographics.
     * @param {customerdemographicsUpdateArgs} args - Arguments to update one Customerdemographics.
     * @example
     * // Update one Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerdemographicsUpdateArgs>(
      args: SelectSubset<T, customerdemographicsUpdateArgs>
    ): CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>>

    /**
     * Delete zero or more Customerdemographics.
     * @param {customerdemographicsDeleteManyArgs} args - Arguments to filter Customerdemographics to delete.
     * @example
     * // Delete a few Customerdemographics
     * const { count } = await prisma.customerdemographics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerdemographicsDeleteManyArgs>(
      args?: SelectSubset<T, customerdemographicsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customerdemographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdemographicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerdemographicsUpdateManyArgs>(
      args: SelectSubset<T, customerdemographicsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customerdemographics.
     * @param {customerdemographicsUpsertArgs} args - Arguments to update or create a Customerdemographics.
     * @example
     * // Update or create a Customerdemographics
     * const customerdemographics = await prisma.customerdemographics.upsert({
     *   create: {
     *     // ... data to create a Customerdemographics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customerdemographics we want to update
     *   }
     * })
    **/
    upsert<T extends customerdemographicsUpsertArgs>(
      args: SelectSubset<T, customerdemographicsUpsertArgs>
    ): CheckSelect<T, Prisma__customerdemographicsClient<customerdemographics>, Prisma__customerdemographicsClient<customerdemographicsGetPayload<T>>>

    /**
     * Count the number of Customerdemographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerdemographicsCountArgs} args - Arguments to filter Customerdemographics to count.
     * @example
     * // Count the number of Customerdemographics
     * const count = await prisma.customerdemographics.count({
     *   where: {
     *     // ... the filter for the Customerdemographics we want to count
     *   }
     * })
    **/
    count<T extends customerdemographicsCountArgs>(
      args?: Subset<T, customerdemographicsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerdemographicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customerdemographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerdemographicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerdemographicsAggregateArgs>(args: Subset<T, CustomerdemographicsAggregateArgs>): PrismaPromise<GetCustomerdemographicsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for customerdemographics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__customerdemographicsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customercustomerdemo<T extends customercustomerdemoFindManyArgs = {}>(args?: Subset<T, customercustomerdemoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<customercustomerdemo>>, PrismaPromise<Array<customercustomerdemoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * customerdemographics findUnique
   */
  export type customerdemographicsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * Throw an Error if a customerdemographics can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customerdemographics to fetch.
    **/
    where: customerdemographicsWhereUniqueInput
  }


  /**
   * customerdemographics findFirst
   */
  export type customerdemographicsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * Throw an Error if a customerdemographics can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customerdemographics to fetch.
    **/
    where?: customerdemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdemographics to fetch.
    **/
    orderBy?: Enumerable<customerdemographicsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerdemographics.
    **/
    cursor?: customerdemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdemographics from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdemographics.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerdemographics.
    **/
    distinct?: Enumerable<CustomerdemographicsScalarFieldEnum>
  }


  /**
   * customerdemographics findMany
   */
  export type customerdemographicsFindManyArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * Filter, which customerdemographics to fetch.
    **/
    where?: customerdemographicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerdemographics to fetch.
    **/
    orderBy?: Enumerable<customerdemographicsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerdemographics.
    **/
    cursor?: customerdemographicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerdemographics from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerdemographics.
    **/
    skip?: number
    distinct?: Enumerable<CustomerdemographicsScalarFieldEnum>
  }


  /**
   * customerdemographics create
   */
  export type customerdemographicsCreateArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * The data needed to create a customerdemographics.
    **/
    data: XOR<customerdemographicsCreateInput, customerdemographicsUncheckedCreateInput>
  }


  /**
   * customerdemographics update
   */
  export type customerdemographicsUpdateArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * The data needed to update a customerdemographics.
    **/
    data: XOR<customerdemographicsUpdateInput, customerdemographicsUncheckedUpdateInput>
    /**
     * Choose, which customerdemographics to update.
    **/
    where: customerdemographicsWhereUniqueInput
  }


  /**
   * customerdemographics updateMany
   */
  export type customerdemographicsUpdateManyArgs = {
    data: XOR<customerdemographicsUpdateManyMutationInput, customerdemographicsUncheckedUpdateManyInput>
    where?: customerdemographicsWhereInput
  }


  /**
   * customerdemographics upsert
   */
  export type customerdemographicsUpsertArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * The filter to search for the customerdemographics to update in case it exists.
    **/
    where: customerdemographicsWhereUniqueInput
    /**
     * In case the customerdemographics found by the `where` argument doesn't exist, create a new customerdemographics with this data.
    **/
    create: XOR<customerdemographicsCreateInput, customerdemographicsUncheckedCreateInput>
    /**
     * In case the customerdemographics was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<customerdemographicsUpdateInput, customerdemographicsUncheckedUpdateInput>
  }


  /**
   * customerdemographics delete
   */
  export type customerdemographicsDeleteArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
    /**
     * Filter which customerdemographics to delete.
    **/
    where: customerdemographicsWhereUniqueInput
  }


  /**
   * customerdemographics deleteMany
   */
  export type customerdemographicsDeleteManyArgs = {
    where?: customerdemographicsWhereInput
  }


  /**
   * customerdemographics without action
   */
  export type customerdemographicsArgs = {
    /**
     * Select specific fields to fetch from the customerdemographics
    **/
    select?: customerdemographicsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customerdemographicsInclude | null
  }



  /**
   * Model customers
   */


  export type AggregateCustomers = {
    count: CustomersCountAggregateOutputType | null
    min: CustomersMinAggregateOutputType | null
    max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersMinAggregateOutputType = {
    CustomerID: string | null
    CompanyName: string | null
    ContactName: string | null
    ContactTitle: string | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    Phone: string | null
    Fax: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    CustomerID: string | null
    CompanyName: string | null
    ContactName: string | null
    ContactTitle: string | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    Phone: string | null
    Fax: string | null
  }

  export type CustomersCountAggregateOutputType = {
    CustomerID: number | null
    CompanyName: number | null
    ContactName: number | null
    ContactTitle: number | null
    Address: number | null
    City: number | null
    Region: number | null
    PostalCode: number | null
    Country: number | null
    Phone: number | null
    Fax: number | null
    _all: number
  }


  export type CustomersMinAggregateInputType = {
    CustomerID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
  }

  export type CustomersMaxAggregateInputType = {
    CustomerID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
  }

  export type CustomersCountAggregateInputType = {
    CustomerID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
    _all?: true
  }

  export type CustomersAggregateArgs = {
    /**
     * Filter which customers to aggregate.
    **/
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
    **/
    orderBy?: Enumerable<customersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
    [P in keyof T & keyof AggregateCustomers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }



  export type customersSelect = {
    CustomerID?: boolean
    CompanyName?: boolean
    ContactName?: boolean
    ContactTitle?: boolean
    Address?: boolean
    City?: boolean
    Region?: boolean
    PostalCode?: boolean
    Country?: boolean
    Phone?: boolean
    Fax?: boolean
    customercustomerdemo?: boolean | customercustomerdemoArgs
    orders?: boolean | ordersFindManyArgs
  }

  export type customersInclude = {
    customercustomerdemo?: boolean | customercustomerdemoArgs
    orders?: boolean | ordersFindManyArgs
  }

  export type customersGetPayload<
    S extends boolean | null | undefined | customersArgs,
    U = keyof S
      > = S extends true
        ? customers
    : S extends undefined
    ? never
    : S extends customersArgs | customersFindManyArgs
    ?'include' extends U
    ? customers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customercustomerdemo'
        ? customercustomerdemoGetPayload<S['include'][P]> | null :
        P extends 'orders'
        ? Array < ordersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof customers ?customers [P]
  : 
          P extends 'customercustomerdemo'
        ? customercustomerdemoGetPayload<S['select'][P]> | null :
        P extends 'orders'
        ? Array < ordersGetPayload<S['select'][P]>>  : never
  } 
    : customers
  : customers


  type customersCountArgs = Merge<
    Omit<customersFindManyArgs, 'select' | 'include'> & {
      select?: CustomersCountAggregateInputType | true
    }
  >

  export interface customersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, customersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'customers'> extends True ? CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>> : CheckSelect<T, Prisma__customersClient<customers | null >, Prisma__customersClient<customersGetPayload<T> | null >>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, customersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'customers'> extends True ? CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>> : CheckSelect<T, Prisma__customersClient<customers | null >, Prisma__customersClient<customersGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `CustomerID`
     * const customersWithCustomerIDOnly = await prisma.customers.findMany({ select: { CustomerID: true } })
     * 
    **/
    findMany<T extends customersFindManyArgs>(
      args?: SelectSubset<T, customersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<customers>>, PrismaPromise<Array<customersGetPayload<T>>>>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends customersCreateArgs>(
      args: SelectSubset<T, customersCreateArgs>
    ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends customersDeleteArgs>(
      args: SelectSubset<T, customersDeleteArgs>
    ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customersUpdateArgs>(
      args: SelectSubset<T, customersUpdateArgs>
    ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customersDeleteManyArgs>(
      args?: SelectSubset<T, customersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customersUpdateManyArgs>(
      args: SelectSubset<T, customersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends customersUpsertArgs>(
      args: SelectSubset<T, customersUpsertArgs>
    ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): PrismaPromise<GetCustomersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__customersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customercustomerdemo<T extends customercustomerdemoArgs = {}>(args?: Subset<T, customercustomerdemoArgs>): CheckSelect<T, Prisma__customercustomerdemoClient<customercustomerdemo | null >, Prisma__customercustomerdemoClient<customercustomerdemoGetPayload<T> | null >>;

    orders<T extends ordersFindManyArgs = {}>(args?: Subset<T, ordersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orders>>, PrismaPromise<Array<ordersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * Throw an Error if a customers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customers to fetch.
    **/
    where: customersWhereUniqueInput
  }


  /**
   * customers findFirst
   */
  export type customersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * Throw an Error if a customers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which customers to fetch.
    **/
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
    **/
    orderBy?: Enumerable<customersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
    **/
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
    **/
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * customers findMany
   */
  export type customersFindManyArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * Filter, which customers to fetch.
    **/
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
    **/
    orderBy?: Enumerable<customersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
    **/
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
    **/
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * customers create
   */
  export type customersCreateArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * The data needed to create a customers.
    **/
    data: XOR<customersCreateInput, customersUncheckedCreateInput>
  }


  /**
   * customers update
   */
  export type customersUpdateArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * The data needed to update a customers.
    **/
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
    **/
    where: customersWhereUniqueInput
  }


  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs = {
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    where?: customersWhereInput
  }


  /**
   * customers upsert
   */
  export type customersUpsertArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * The filter to search for the customers to update in case it exists.
    **/
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
    **/
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }


  /**
   * customers delete
   */
  export type customersDeleteArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
    /**
     * Filter which customers to delete.
    **/
    where: customersWhereUniqueInput
  }


  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs = {
    where?: customersWhereInput
  }


  /**
   * customers without action
   */
  export type customersArgs = {
    /**
     * Select specific fields to fetch from the customers
    **/
    select?: customersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: customersInclude | null
  }



  /**
   * Model employees
   */


  export type AggregateEmployees = {
    count: EmployeesCountAggregateOutputType | null
    avg: EmployeesAvgAggregateOutputType | null
    sum: EmployeesSumAggregateOutputType | null
    min: EmployeesMinAggregateOutputType | null
    max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    EmployeeID: number
    ReportsTo: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    EmployeeID: number
    ReportsTo: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    EmployeeID: number
    LastName: string | null
    FirstName: string | null
    Title: string | null
    TitleOfCourtesy: string | null
    BirthDate: Date | null
    HireDate: Date | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    HomePhone: string | null
    Extension: string | null
    Photo: Buffer | null
    Notes: string | null
    ReportsTo: number | null
    PhotoPath: string | null
  }

  export type EmployeesMaxAggregateOutputType = {
    EmployeeID: number
    LastName: string | null
    FirstName: string | null
    Title: string | null
    TitleOfCourtesy: string | null
    BirthDate: Date | null
    HireDate: Date | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    HomePhone: string | null
    Extension: string | null
    Photo: Buffer | null
    Notes: string | null
    ReportsTo: number | null
    PhotoPath: string | null
  }

  export type EmployeesCountAggregateOutputType = {
    EmployeeID: number
    LastName: number | null
    FirstName: number | null
    Title: number | null
    TitleOfCourtesy: number | null
    BirthDate: number | null
    HireDate: number | null
    Address: number | null
    City: number | null
    Region: number | null
    PostalCode: number | null
    Country: number | null
    HomePhone: number | null
    Extension: number | null
    Photo: number | null
    Notes: number | null
    ReportsTo: number | null
    PhotoPath: number | null
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    EmployeeID?: true
    ReportsTo?: true
  }

  export type EmployeesSumAggregateInputType = {
    EmployeeID?: true
    ReportsTo?: true
  }

  export type EmployeesMinAggregateInputType = {
    EmployeeID?: true
    LastName?: true
    FirstName?: true
    Title?: true
    TitleOfCourtesy?: true
    BirthDate?: true
    HireDate?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    HomePhone?: true
    Extension?: true
    Photo?: true
    Notes?: true
    ReportsTo?: true
    PhotoPath?: true
  }

  export type EmployeesMaxAggregateInputType = {
    EmployeeID?: true
    LastName?: true
    FirstName?: true
    Title?: true
    TitleOfCourtesy?: true
    BirthDate?: true
    HireDate?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    HomePhone?: true
    Extension?: true
    Photo?: true
    Notes?: true
    ReportsTo?: true
    PhotoPath?: true
  }

  export type EmployeesCountAggregateInputType = {
    EmployeeID?: true
    LastName?: true
    FirstName?: true
    Title?: true
    TitleOfCourtesy?: true
    BirthDate?: true
    HireDate?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    HomePhone?: true
    Extension?: true
    Photo?: true
    Notes?: true
    ReportsTo?: true
    PhotoPath?: true
    _all?: true
  }

  export type EmployeesAggregateArgs = {
    /**
     * Filter which employees to aggregate.
    **/
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
    **/
    orderBy?: Enumerable<employeesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
    [P in keyof T & keyof AggregateEmployees]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }



  export type employeesSelect = {
    EmployeeID?: boolean
    LastName?: boolean
    FirstName?: boolean
    Title?: boolean
    TitleOfCourtesy?: boolean
    BirthDate?: boolean
    HireDate?: boolean
    Address?: boolean
    City?: boolean
    Region?: boolean
    PostalCode?: boolean
    Country?: boolean
    HomePhone?: boolean
    Extension?: boolean
    Photo?: boolean
    Notes?: boolean
    ReportsTo?: boolean
    PhotoPath?: boolean
    employeeterritories?: boolean | employeeterritoriesArgs
    orders?: boolean | ordersFindManyArgs
  }

  export type employeesInclude = {
    employeeterritories?: boolean | employeeterritoriesArgs
    orders?: boolean | ordersFindManyArgs
  }

  export type employeesGetPayload<
    S extends boolean | null | undefined | employeesArgs,
    U = keyof S
      > = S extends true
        ? employees
    : S extends undefined
    ? never
    : S extends employeesArgs | employeesFindManyArgs
    ?'include' extends U
    ? employees  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'employeeterritories'
        ? employeeterritoriesGetPayload<S['include'][P]> | null :
        P extends 'orders'
        ? Array < ordersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof employees ?employees [P]
  : 
          P extends 'employeeterritories'
        ? employeeterritoriesGetPayload<S['select'][P]> | null :
        P extends 'orders'
        ? Array < ordersGetPayload<S['select'][P]>>  : never
  } 
    : employees
  : employees


  type employeesCountArgs = Merge<
    Omit<employeesFindManyArgs, 'select' | 'include'> & {
      select?: EmployeesCountAggregateInputType | true
    }
  >

  export interface employeesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Employees that matches the filter.
     * @param {employeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends employeesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, employeesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'employees'> extends True ? CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>> : CheckSelect<T, Prisma__employeesClient<employees | null >, Prisma__employeesClient<employeesGetPayload<T> | null >>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends employeesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, employeesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'employees'> extends True ? CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>> : CheckSelect<T, Prisma__employeesClient<employees | null >, Prisma__employeesClient<employeesGetPayload<T> | null >>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeID`
     * const employeesWithEmployeeIDOnly = await prisma.employees.findMany({ select: { EmployeeID: true } })
     * 
    **/
    findMany<T extends employeesFindManyArgs>(
      args?: SelectSubset<T, employeesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<employees>>, PrismaPromise<Array<employeesGetPayload<T>>>>

    /**
     * Create a Employees.
     * @param {employeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
    **/
    create<T extends employeesCreateArgs>(
      args: SelectSubset<T, employeesCreateArgs>
    ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>

    /**
     * Delete a Employees.
     * @param {employeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
    **/
    delete<T extends employeesDeleteArgs>(
      args: SelectSubset<T, employeesDeleteArgs>
    ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>

    /**
     * Update one Employees.
     * @param {employeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends employeesUpdateArgs>(
      args: SelectSubset<T, employeesUpdateArgs>
    ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>

    /**
     * Delete zero or more Employees.
     * @param {employeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends employeesDeleteManyArgs>(
      args?: SelectSubset<T, employeesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends employeesUpdateManyArgs>(
      args: SelectSubset<T, employeesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Employees.
     * @param {employeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
    **/
    upsert<T extends employeesUpsertArgs>(
      args: SelectSubset<T, employeesUpsertArgs>
    ): CheckSelect<T, Prisma__employeesClient<employees>, Prisma__employeesClient<employeesGetPayload<T>>>

    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeesCountArgs>(
      args?: Subset<T, employeesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): PrismaPromise<GetEmployeesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__employeesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employeeterritories<T extends employeeterritoriesArgs = {}>(args?: Subset<T, employeeterritoriesArgs>): CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories | null >, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T> | null >>;

    orders<T extends ordersFindManyArgs = {}>(args?: Subset<T, ordersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orders>>, PrismaPromise<Array<ordersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * employees findUnique
   */
  export type employeesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * Throw an Error if a employees can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which employees to fetch.
    **/
    where: employeesWhereUniqueInput
  }


  /**
   * employees findFirst
   */
  export type employeesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * Throw an Error if a employees can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which employees to fetch.
    **/
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
    **/
    orderBy?: Enumerable<employeesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
    **/
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
    **/
    distinct?: Enumerable<EmployeesScalarFieldEnum>
  }


  /**
   * employees findMany
   */
  export type employeesFindManyArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * Filter, which employees to fetch.
    **/
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
    **/
    orderBy?: Enumerable<employeesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
    **/
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
    **/
    skip?: number
    distinct?: Enumerable<EmployeesScalarFieldEnum>
  }


  /**
   * employees create
   */
  export type employeesCreateArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * The data needed to create a employees.
    **/
    data: XOR<employeesCreateInput, employeesUncheckedCreateInput>
  }


  /**
   * employees update
   */
  export type employeesUpdateArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * The data needed to update a employees.
    **/
    data: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
    /**
     * Choose, which employees to update.
    **/
    where: employeesWhereUniqueInput
  }


  /**
   * employees updateMany
   */
  export type employeesUpdateManyArgs = {
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    where?: employeesWhereInput
  }


  /**
   * employees upsert
   */
  export type employeesUpsertArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * The filter to search for the employees to update in case it exists.
    **/
    where: employeesWhereUniqueInput
    /**
     * In case the employees found by the `where` argument doesn't exist, create a new employees with this data.
    **/
    create: XOR<employeesCreateInput, employeesUncheckedCreateInput>
    /**
     * In case the employees was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
  }


  /**
   * employees delete
   */
  export type employeesDeleteArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
    /**
     * Filter which employees to delete.
    **/
    where: employeesWhereUniqueInput
  }


  /**
   * employees deleteMany
   */
  export type employeesDeleteManyArgs = {
    where?: employeesWhereInput
  }


  /**
   * employees without action
   */
  export type employeesArgs = {
    /**
     * Select specific fields to fetch from the employees
    **/
    select?: employeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeesInclude | null
  }



  /**
   * Model employeeterritories
   */


  export type AggregateEmployeeterritories = {
    count: EmployeeterritoriesCountAggregateOutputType | null
    avg: EmployeeterritoriesAvgAggregateOutputType | null
    sum: EmployeeterritoriesSumAggregateOutputType | null
    min: EmployeeterritoriesMinAggregateOutputType | null
    max: EmployeeterritoriesMaxAggregateOutputType | null
  }

  export type EmployeeterritoriesAvgAggregateOutputType = {
    EmployeeID: number
  }

  export type EmployeeterritoriesSumAggregateOutputType = {
    EmployeeID: number
  }

  export type EmployeeterritoriesMinAggregateOutputType = {
    EmployeeID: number
    TerritoryID: string | null
  }

  export type EmployeeterritoriesMaxAggregateOutputType = {
    EmployeeID: number
    TerritoryID: string | null
  }

  export type EmployeeterritoriesCountAggregateOutputType = {
    EmployeeID: number
    TerritoryID: number | null
    _all: number
  }


  export type EmployeeterritoriesAvgAggregateInputType = {
    EmployeeID?: true
  }

  export type EmployeeterritoriesSumAggregateInputType = {
    EmployeeID?: true
  }

  export type EmployeeterritoriesMinAggregateInputType = {
    EmployeeID?: true
    TerritoryID?: true
  }

  export type EmployeeterritoriesMaxAggregateInputType = {
    EmployeeID?: true
    TerritoryID?: true
  }

  export type EmployeeterritoriesCountAggregateInputType = {
    EmployeeID?: true
    TerritoryID?: true
    _all?: true
  }

  export type EmployeeterritoriesAggregateArgs = {
    /**
     * Filter which employeeterritories to aggregate.
    **/
    where?: employeeterritoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeterritories to fetch.
    **/
    orderBy?: Enumerable<employeeterritoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: employeeterritoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeterritories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeterritories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employeeterritories
    **/
    count?: true | EmployeeterritoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EmployeeterritoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EmployeeterritoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EmployeeterritoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EmployeeterritoriesMaxAggregateInputType
  }

  export type GetEmployeeterritoriesAggregateType<T extends EmployeeterritoriesAggregateArgs> = {
    [P in keyof T & keyof AggregateEmployeeterritories]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeterritories[P]>
      : GetScalarType<T[P], AggregateEmployeeterritories[P]>
  }



  export type employeeterritoriesSelect = {
    EmployeeID?: boolean
    TerritoryID?: boolean
    employees?: boolean | employeesArgs
    territories?: boolean | territoriesArgs
  }

  export type employeeterritoriesInclude = {
    employees?: boolean | employeesArgs
    territories?: boolean | territoriesArgs
  }

  export type employeeterritoriesGetPayload<
    S extends boolean | null | undefined | employeeterritoriesArgs,
    U = keyof S
      > = S extends true
        ? employeeterritories
    : S extends undefined
    ? never
    : S extends employeeterritoriesArgs | employeeterritoriesFindManyArgs
    ?'include' extends U
    ? employeeterritories  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'employees'
        ? employeesGetPayload<S['include'][P]> :
        P extends 'territories'
        ? territoriesGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof employeeterritories ?employeeterritories [P]
  : 
          P extends 'employees'
        ? employeesGetPayload<S['select'][P]> :
        P extends 'territories'
        ? territoriesGetPayload<S['select'][P]> | null : never
  } 
    : employeeterritories
  : employeeterritories


  type employeeterritoriesCountArgs = Merge<
    Omit<employeeterritoriesFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeterritoriesCountAggregateInputType | true
    }
  >

  export interface employeeterritoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Employeeterritories that matches the filter.
     * @param {employeeterritoriesFindUniqueArgs} args - Arguments to find a Employeeterritories
     * @example
     * // Get one Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends employeeterritoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, employeeterritoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'employeeterritories'> extends True ? CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>> : CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories | null >, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T> | null >>

    /**
     * Find the first Employeeterritories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeterritoriesFindFirstArgs} args - Arguments to find a Employeeterritories
     * @example
     * // Get one Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends employeeterritoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, employeeterritoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'employeeterritories'> extends True ? CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>> : CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories | null >, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T> | null >>

    /**
     * Find zero or more Employeeterritories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeterritoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.findMany()
     * 
     * // Get first 10 Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeID`
     * const employeeterritoriesWithEmployeeIDOnly = await prisma.employeeterritories.findMany({ select: { EmployeeID: true } })
     * 
    **/
    findMany<T extends employeeterritoriesFindManyArgs>(
      args?: SelectSubset<T, employeeterritoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<employeeterritories>>, PrismaPromise<Array<employeeterritoriesGetPayload<T>>>>

    /**
     * Create a Employeeterritories.
     * @param {employeeterritoriesCreateArgs} args - Arguments to create a Employeeterritories.
     * @example
     * // Create one Employeeterritories
     * const Employeeterritories = await prisma.employeeterritories.create({
     *   data: {
     *     // ... data to create a Employeeterritories
     *   }
     * })
     * 
    **/
    create<T extends employeeterritoriesCreateArgs>(
      args: SelectSubset<T, employeeterritoriesCreateArgs>
    ): CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>>

    /**
     * Delete a Employeeterritories.
     * @param {employeeterritoriesDeleteArgs} args - Arguments to delete one Employeeterritories.
     * @example
     * // Delete one Employeeterritories
     * const Employeeterritories = await prisma.employeeterritories.delete({
     *   where: {
     *     // ... filter to delete one Employeeterritories
     *   }
     * })
     * 
    **/
    delete<T extends employeeterritoriesDeleteArgs>(
      args: SelectSubset<T, employeeterritoriesDeleteArgs>
    ): CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>>

    /**
     * Update one Employeeterritories.
     * @param {employeeterritoriesUpdateArgs} args - Arguments to update one Employeeterritories.
     * @example
     * // Update one Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends employeeterritoriesUpdateArgs>(
      args: SelectSubset<T, employeeterritoriesUpdateArgs>
    ): CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>>

    /**
     * Delete zero or more Employeeterritories.
     * @param {employeeterritoriesDeleteManyArgs} args - Arguments to filter Employeeterritories to delete.
     * @example
     * // Delete a few Employeeterritories
     * const { count } = await prisma.employeeterritories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends employeeterritoriesDeleteManyArgs>(
      args?: SelectSubset<T, employeeterritoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employeeterritories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeterritoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends employeeterritoriesUpdateManyArgs>(
      args: SelectSubset<T, employeeterritoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Employeeterritories.
     * @param {employeeterritoriesUpsertArgs} args - Arguments to update or create a Employeeterritories.
     * @example
     * // Update or create a Employeeterritories
     * const employeeterritories = await prisma.employeeterritories.upsert({
     *   create: {
     *     // ... data to create a Employeeterritories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employeeterritories we want to update
     *   }
     * })
    **/
    upsert<T extends employeeterritoriesUpsertArgs>(
      args: SelectSubset<T, employeeterritoriesUpsertArgs>
    ): CheckSelect<T, Prisma__employeeterritoriesClient<employeeterritories>, Prisma__employeeterritoriesClient<employeeterritoriesGetPayload<T>>>

    /**
     * Count the number of Employeeterritories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeterritoriesCountArgs} args - Arguments to filter Employeeterritories to count.
     * @example
     * // Count the number of Employeeterritories
     * const count = await prisma.employeeterritories.count({
     *   where: {
     *     // ... the filter for the Employeeterritories we want to count
     *   }
     * })
    **/
    count<T extends employeeterritoriesCountArgs>(
      args?: Subset<T, employeeterritoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeterritoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employeeterritories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeterritoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeterritoriesAggregateArgs>(args: Subset<T, EmployeeterritoriesAggregateArgs>): PrismaPromise<GetEmployeeterritoriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for employeeterritories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__employeeterritoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employees<T extends employeesArgs = {}>(args?: Subset<T, employeesArgs>): CheckSelect<T, Prisma__employeesClient<employees | null >, Prisma__employeesClient<employeesGetPayload<T> | null >>;

    territories<T extends territoriesArgs = {}>(args?: Subset<T, territoriesArgs>): CheckSelect<T, Prisma__territoriesClient<territories | null >, Prisma__territoriesClient<territoriesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * employeeterritories findUnique
   */
  export type employeeterritoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * Throw an Error if a employeeterritories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which employeeterritories to fetch.
    **/
    where: employeeterritoriesWhereUniqueInput
  }


  /**
   * employeeterritories findFirst
   */
  export type employeeterritoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * Throw an Error if a employeeterritories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which employeeterritories to fetch.
    **/
    where?: employeeterritoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeterritories to fetch.
    **/
    orderBy?: Enumerable<employeeterritoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeeterritories.
    **/
    cursor?: employeeterritoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeterritories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeterritories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeeterritories.
    **/
    distinct?: Enumerable<EmployeeterritoriesScalarFieldEnum>
  }


  /**
   * employeeterritories findMany
   */
  export type employeeterritoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * Filter, which employeeterritories to fetch.
    **/
    where?: employeeterritoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeterritories to fetch.
    **/
    orderBy?: Enumerable<employeeterritoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employeeterritories.
    **/
    cursor?: employeeterritoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeterritories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeterritories.
    **/
    skip?: number
    distinct?: Enumerable<EmployeeterritoriesScalarFieldEnum>
  }


  /**
   * employeeterritories create
   */
  export type employeeterritoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * The data needed to create a employeeterritories.
    **/
    data: XOR<employeeterritoriesCreateInput, employeeterritoriesUncheckedCreateInput>
  }


  /**
   * employeeterritories update
   */
  export type employeeterritoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * The data needed to update a employeeterritories.
    **/
    data: XOR<employeeterritoriesUpdateInput, employeeterritoriesUncheckedUpdateInput>
    /**
     * Choose, which employeeterritories to update.
    **/
    where: employeeterritoriesWhereUniqueInput
  }


  /**
   * employeeterritories updateMany
   */
  export type employeeterritoriesUpdateManyArgs = {
    data: XOR<employeeterritoriesUpdateManyMutationInput, employeeterritoriesUncheckedUpdateManyInput>
    where?: employeeterritoriesWhereInput
  }


  /**
   * employeeterritories upsert
   */
  export type employeeterritoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * The filter to search for the employeeterritories to update in case it exists.
    **/
    where: employeeterritoriesWhereUniqueInput
    /**
     * In case the employeeterritories found by the `where` argument doesn't exist, create a new employeeterritories with this data.
    **/
    create: XOR<employeeterritoriesCreateInput, employeeterritoriesUncheckedCreateInput>
    /**
     * In case the employeeterritories was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<employeeterritoriesUpdateInput, employeeterritoriesUncheckedUpdateInput>
  }


  /**
   * employeeterritories delete
   */
  export type employeeterritoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
    /**
     * Filter which employeeterritories to delete.
    **/
    where: employeeterritoriesWhereUniqueInput
  }


  /**
   * employeeterritories deleteMany
   */
  export type employeeterritoriesDeleteManyArgs = {
    where?: employeeterritoriesWhereInput
  }


  /**
   * employeeterritories without action
   */
  export type employeeterritoriesArgs = {
    /**
     * Select specific fields to fetch from the employeeterritories
    **/
    select?: employeeterritoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: employeeterritoriesInclude | null
  }



  /**
   * Model orderdetails
   */


  export type AggregateOrderdetails = {
    count: OrderdetailsCountAggregateOutputType | null
    avg: OrderdetailsAvgAggregateOutputType | null
    sum: OrderdetailsSumAggregateOutputType | null
    min: OrderdetailsMinAggregateOutputType | null
    max: OrderdetailsMaxAggregateOutputType | null
  }

  export type OrderdetailsAvgAggregateOutputType = {
    OrderID: number
    ProductID: number | null
    UnitPrice: Decimal | null
    Quantity: number | null
    Discount: number | null
  }

  export type OrderdetailsSumAggregateOutputType = {
    OrderID: number
    ProductID: number | null
    UnitPrice: Decimal | null
    Quantity: number | null
    Discount: number | null
  }

  export type OrderdetailsMinAggregateOutputType = {
    OrderID: number
    ProductID: number | null
    UnitPrice: Decimal | null
    Quantity: number | null
    Discount: number | null
  }

  export type OrderdetailsMaxAggregateOutputType = {
    OrderID: number
    ProductID: number | null
    UnitPrice: Decimal | null
    Quantity: number | null
    Discount: number | null
  }

  export type OrderdetailsCountAggregateOutputType = {
    OrderID: number
    ProductID: number | null
    UnitPrice: number | null
    Quantity: number | null
    Discount: number | null
    _all: number
  }


  export type OrderdetailsAvgAggregateInputType = {
    OrderID?: true
    ProductID?: true
    UnitPrice?: true
    Quantity?: true
    Discount?: true
  }

  export type OrderdetailsSumAggregateInputType = {
    OrderID?: true
    ProductID?: true
    UnitPrice?: true
    Quantity?: true
    Discount?: true
  }

  export type OrderdetailsMinAggregateInputType = {
    OrderID?: true
    ProductID?: true
    UnitPrice?: true
    Quantity?: true
    Discount?: true
  }

  export type OrderdetailsMaxAggregateInputType = {
    OrderID?: true
    ProductID?: true
    UnitPrice?: true
    Quantity?: true
    Discount?: true
  }

  export type OrderdetailsCountAggregateInputType = {
    OrderID?: true
    ProductID?: true
    UnitPrice?: true
    Quantity?: true
    Discount?: true
    _all?: true
  }

  export type OrderdetailsAggregateArgs = {
    /**
     * Filter which orderdetails to aggregate.
    **/
    where?: orderdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderdetails to fetch.
    **/
    orderBy?: Enumerable<orderdetailsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: orderdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderdetails from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderdetails.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderdetails
    **/
    count?: true | OrderdetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: OrderdetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: OrderdetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: OrderdetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: OrderdetailsMaxAggregateInputType
  }

  export type GetOrderdetailsAggregateType<T extends OrderdetailsAggregateArgs> = {
    [P in keyof T & keyof AggregateOrderdetails]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderdetails[P]>
      : GetScalarType<T[P], AggregateOrderdetails[P]>
  }



  export type orderdetailsSelect = {
    OrderID?: boolean
    ProductID?: boolean
    UnitPrice?: boolean
    Quantity?: boolean
    Discount?: boolean
    orders?: boolean | ordersArgs
    products?: boolean | productsArgs
  }

  export type orderdetailsInclude = {
    orders?: boolean | ordersArgs
    products?: boolean | productsArgs
  }

  export type orderdetailsGetPayload<
    S extends boolean | null | undefined | orderdetailsArgs,
    U = keyof S
      > = S extends true
        ? orderdetails
    : S extends undefined
    ? never
    : S extends orderdetailsArgs | orderdetailsFindManyArgs
    ?'include' extends U
    ? orderdetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'orders'
        ? ordersGetPayload<S['include'][P]> :
        P extends 'products'
        ? productsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof orderdetails ?orderdetails [P]
  : 
          P extends 'orders'
        ? ordersGetPayload<S['select'][P]> :
        P extends 'products'
        ? productsGetPayload<S['select'][P]> | null : never
  } 
    : orderdetails
  : orderdetails


  type orderdetailsCountArgs = Merge<
    Omit<orderdetailsFindManyArgs, 'select' | 'include'> & {
      select?: OrderdetailsCountAggregateInputType | true
    }
  >

  export interface orderdetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Orderdetails that matches the filter.
     * @param {orderdetailsFindUniqueArgs} args - Arguments to find a Orderdetails
     * @example
     * // Get one Orderdetails
     * const orderdetails = await prisma.orderdetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderdetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, orderdetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'orderdetails'> extends True ? CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>> : CheckSelect<T, Prisma__orderdetailsClient<orderdetails | null >, Prisma__orderdetailsClient<orderdetailsGetPayload<T> | null >>

    /**
     * Find the first Orderdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderdetailsFindFirstArgs} args - Arguments to find a Orderdetails
     * @example
     * // Get one Orderdetails
     * const orderdetails = await prisma.orderdetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderdetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, orderdetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'orderdetails'> extends True ? CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>> : CheckSelect<T, Prisma__orderdetailsClient<orderdetails | null >, Prisma__orderdetailsClient<orderdetailsGetPayload<T> | null >>

    /**
     * Find zero or more Orderdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderdetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orderdetails
     * const orderdetails = await prisma.orderdetails.findMany()
     * 
     * // Get first 10 Orderdetails
     * const orderdetails = await prisma.orderdetails.findMany({ take: 10 })
     * 
     * // Only select the `OrderID`
     * const orderdetailsWithOrderIDOnly = await prisma.orderdetails.findMany({ select: { OrderID: true } })
     * 
    **/
    findMany<T extends orderdetailsFindManyArgs>(
      args?: SelectSubset<T, orderdetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<orderdetails>>, PrismaPromise<Array<orderdetailsGetPayload<T>>>>

    /**
     * Create a Orderdetails.
     * @param {orderdetailsCreateArgs} args - Arguments to create a Orderdetails.
     * @example
     * // Create one Orderdetails
     * const Orderdetails = await prisma.orderdetails.create({
     *   data: {
     *     // ... data to create a Orderdetails
     *   }
     * })
     * 
    **/
    create<T extends orderdetailsCreateArgs>(
      args: SelectSubset<T, orderdetailsCreateArgs>
    ): CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>>

    /**
     * Delete a Orderdetails.
     * @param {orderdetailsDeleteArgs} args - Arguments to delete one Orderdetails.
     * @example
     * // Delete one Orderdetails
     * const Orderdetails = await prisma.orderdetails.delete({
     *   where: {
     *     // ... filter to delete one Orderdetails
     *   }
     * })
     * 
    **/
    delete<T extends orderdetailsDeleteArgs>(
      args: SelectSubset<T, orderdetailsDeleteArgs>
    ): CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>>

    /**
     * Update one Orderdetails.
     * @param {orderdetailsUpdateArgs} args - Arguments to update one Orderdetails.
     * @example
     * // Update one Orderdetails
     * const orderdetails = await prisma.orderdetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderdetailsUpdateArgs>(
      args: SelectSubset<T, orderdetailsUpdateArgs>
    ): CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>>

    /**
     * Delete zero or more Orderdetails.
     * @param {orderdetailsDeleteManyArgs} args - Arguments to filter Orderdetails to delete.
     * @example
     * // Delete a few Orderdetails
     * const { count } = await prisma.orderdetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderdetailsDeleteManyArgs>(
      args?: SelectSubset<T, orderdetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderdetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orderdetails
     * const orderdetails = await prisma.orderdetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderdetailsUpdateManyArgs>(
      args: SelectSubset<T, orderdetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orderdetails.
     * @param {orderdetailsUpsertArgs} args - Arguments to update or create a Orderdetails.
     * @example
     * // Update or create a Orderdetails
     * const orderdetails = await prisma.orderdetails.upsert({
     *   create: {
     *     // ... data to create a Orderdetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orderdetails we want to update
     *   }
     * })
    **/
    upsert<T extends orderdetailsUpsertArgs>(
      args: SelectSubset<T, orderdetailsUpsertArgs>
    ): CheckSelect<T, Prisma__orderdetailsClient<orderdetails>, Prisma__orderdetailsClient<orderdetailsGetPayload<T>>>

    /**
     * Count the number of Orderdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderdetailsCountArgs} args - Arguments to filter Orderdetails to count.
     * @example
     * // Count the number of Orderdetails
     * const count = await prisma.orderdetails.count({
     *   where: {
     *     // ... the filter for the Orderdetails we want to count
     *   }
     * })
    **/
    count<T extends orderdetailsCountArgs>(
      args?: Subset<T, orderdetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderdetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orderdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderdetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderdetailsAggregateArgs>(args: Subset<T, OrderdetailsAggregateArgs>): PrismaPromise<GetOrderdetailsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for orderdetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderdetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orders<T extends ordersArgs = {}>(args?: Subset<T, ordersArgs>): CheckSelect<T, Prisma__ordersClient<orders | null >, Prisma__ordersClient<ordersGetPayload<T> | null >>;

    products<T extends productsArgs = {}>(args?: Subset<T, productsArgs>): CheckSelect<T, Prisma__productsClient<products | null >, Prisma__productsClient<productsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * orderdetails findUnique
   */
  export type orderdetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * Throw an Error if a orderdetails can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderdetails to fetch.
    **/
    where: orderdetailsWhereUniqueInput
  }


  /**
   * orderdetails findFirst
   */
  export type orderdetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * Throw an Error if a orderdetails can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderdetails to fetch.
    **/
    where?: orderdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderdetails to fetch.
    **/
    orderBy?: Enumerable<orderdetailsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderdetails.
    **/
    cursor?: orderdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderdetails from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderdetails.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderdetails.
    **/
    distinct?: Enumerable<OrderdetailsScalarFieldEnum>
  }


  /**
   * orderdetails findMany
   */
  export type orderdetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * Filter, which orderdetails to fetch.
    **/
    where?: orderdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderdetails to fetch.
    **/
    orderBy?: Enumerable<orderdetailsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderdetails.
    **/
    cursor?: orderdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderdetails from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderdetails.
    **/
    skip?: number
    distinct?: Enumerable<OrderdetailsScalarFieldEnum>
  }


  /**
   * orderdetails create
   */
  export type orderdetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * The data needed to create a orderdetails.
    **/
    data: XOR<orderdetailsCreateInput, orderdetailsUncheckedCreateInput>
  }


  /**
   * orderdetails update
   */
  export type orderdetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * The data needed to update a orderdetails.
    **/
    data: XOR<orderdetailsUpdateInput, orderdetailsUncheckedUpdateInput>
    /**
     * Choose, which orderdetails to update.
    **/
    where: orderdetailsWhereUniqueInput
  }


  /**
   * orderdetails updateMany
   */
  export type orderdetailsUpdateManyArgs = {
    data: XOR<orderdetailsUpdateManyMutationInput, orderdetailsUncheckedUpdateManyInput>
    where?: orderdetailsWhereInput
  }


  /**
   * orderdetails upsert
   */
  export type orderdetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * The filter to search for the orderdetails to update in case it exists.
    **/
    where: orderdetailsWhereUniqueInput
    /**
     * In case the orderdetails found by the `where` argument doesn't exist, create a new orderdetails with this data.
    **/
    create: XOR<orderdetailsCreateInput, orderdetailsUncheckedCreateInput>
    /**
     * In case the orderdetails was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<orderdetailsUpdateInput, orderdetailsUncheckedUpdateInput>
  }


  /**
   * orderdetails delete
   */
  export type orderdetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
    /**
     * Filter which orderdetails to delete.
    **/
    where: orderdetailsWhereUniqueInput
  }


  /**
   * orderdetails deleteMany
   */
  export type orderdetailsDeleteManyArgs = {
    where?: orderdetailsWhereInput
  }


  /**
   * orderdetails without action
   */
  export type orderdetailsArgs = {
    /**
     * Select specific fields to fetch from the orderdetails
    **/
    select?: orderdetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: orderdetailsInclude | null
  }



  /**
   * Model orders
   */


  export type AggregateOrders = {
    count: OrdersCountAggregateOutputType | null
    avg: OrdersAvgAggregateOutputType | null
    sum: OrdersSumAggregateOutputType | null
    min: OrdersMinAggregateOutputType | null
    max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    OrderID: number
    EmployeeID: number | null
    ShipVia: number | null
    Freight: Decimal | null
  }

  export type OrdersSumAggregateOutputType = {
    OrderID: number
    EmployeeID: number | null
    ShipVia: number | null
    Freight: Decimal | null
  }

  export type OrdersMinAggregateOutputType = {
    OrderID: number
    CustomerID: string | null
    EmployeeID: number | null
    OrderDate: Date | null
    RequiredDate: Date | null
    ShippedDate: Date | null
    ShipVia: number | null
    Freight: Decimal | null
    ShipName: string | null
    ShipAddress: string | null
    ShipCity: string | null
    ShipRegion: string | null
    ShipPostalCode: string | null
    ShipCountry: string | null
  }

  export type OrdersMaxAggregateOutputType = {
    OrderID: number
    CustomerID: string | null
    EmployeeID: number | null
    OrderDate: Date | null
    RequiredDate: Date | null
    ShippedDate: Date | null
    ShipVia: number | null
    Freight: Decimal | null
    ShipName: string | null
    ShipAddress: string | null
    ShipCity: string | null
    ShipRegion: string | null
    ShipPostalCode: string | null
    ShipCountry: string | null
  }

  export type OrdersCountAggregateOutputType = {
    OrderID: number
    CustomerID: number | null
    EmployeeID: number | null
    OrderDate: number | null
    RequiredDate: number | null
    ShippedDate: number | null
    ShipVia: number | null
    Freight: number | null
    ShipName: number | null
    ShipAddress: number | null
    ShipCity: number | null
    ShipRegion: number | null
    ShipPostalCode: number | null
    ShipCountry: number | null
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    OrderID?: true
    EmployeeID?: true
    ShipVia?: true
    Freight?: true
  }

  export type OrdersSumAggregateInputType = {
    OrderID?: true
    EmployeeID?: true
    ShipVia?: true
    Freight?: true
  }

  export type OrdersMinAggregateInputType = {
    OrderID?: true
    CustomerID?: true
    EmployeeID?: true
    OrderDate?: true
    RequiredDate?: true
    ShippedDate?: true
    ShipVia?: true
    Freight?: true
    ShipName?: true
    ShipAddress?: true
    ShipCity?: true
    ShipRegion?: true
    ShipPostalCode?: true
    ShipCountry?: true
  }

  export type OrdersMaxAggregateInputType = {
    OrderID?: true
    CustomerID?: true
    EmployeeID?: true
    OrderDate?: true
    RequiredDate?: true
    ShippedDate?: true
    ShipVia?: true
    Freight?: true
    ShipName?: true
    ShipAddress?: true
    ShipCity?: true
    ShipRegion?: true
    ShipPostalCode?: true
    ShipCountry?: true
  }

  export type OrdersCountAggregateInputType = {
    OrderID?: true
    CustomerID?: true
    EmployeeID?: true
    OrderDate?: true
    RequiredDate?: true
    ShippedDate?: true
    ShipVia?: true
    Freight?: true
    ShipName?: true
    ShipAddress?: true
    ShipCity?: true
    ShipRegion?: true
    ShipPostalCode?: true
    ShipCountry?: true
    _all?: true
  }

  export type OrdersAggregateArgs = {
    /**
     * Filter which orders to aggregate.
    **/
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
    **/
    orderBy?: Enumerable<ordersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
    [P in keyof T & keyof AggregateOrders]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }



  export type ordersSelect = {
    OrderID?: boolean
    CustomerID?: boolean
    EmployeeID?: boolean
    OrderDate?: boolean
    RequiredDate?: boolean
    ShippedDate?: boolean
    ShipVia?: boolean
    Freight?: boolean
    ShipName?: boolean
    ShipAddress?: boolean
    ShipCity?: boolean
    ShipRegion?: boolean
    ShipPostalCode?: boolean
    ShipCountry?: boolean
    customers?: boolean | customersArgs
    employees?: boolean | employeesArgs
    shippers?: boolean | shippersArgs
    orderdetails?: boolean | orderdetailsArgs
  }

  export type ordersInclude = {
    customers?: boolean | customersArgs
    employees?: boolean | employeesArgs
    shippers?: boolean | shippersArgs
    orderdetails?: boolean | orderdetailsArgs
  }

  export type ordersGetPayload<
    S extends boolean | null | undefined | ordersArgs,
    U = keyof S
      > = S extends true
        ? orders
    : S extends undefined
    ? never
    : S extends ordersArgs | ordersFindManyArgs
    ?'include' extends U
    ? orders  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customers'
        ? customersGetPayload<S['include'][P]> :
        P extends 'employees'
        ? employeesGetPayload<S['include'][P]> | null :
        P extends 'shippers'
        ? shippersGetPayload<S['include'][P]> | null :
        P extends 'orderdetails'
        ? orderdetailsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof orders ?orders [P]
  : 
          P extends 'customers'
        ? customersGetPayload<S['select'][P]> :
        P extends 'employees'
        ? employeesGetPayload<S['select'][P]> | null :
        P extends 'shippers'
        ? shippersGetPayload<S['select'][P]> | null :
        P extends 'orderdetails'
        ? orderdetailsGetPayload<S['select'][P]> | null : never
  } 
    : orders
  : orders


  type ordersCountArgs = Merge<
    Omit<ordersFindManyArgs, 'select' | 'include'> & {
      select?: OrdersCountAggregateInputType | true
    }
  >

  export interface ordersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ordersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ordersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'orders'> extends True ? CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>> : CheckSelect<T, Prisma__ordersClient<orders | null >, Prisma__ordersClient<ordersGetPayload<T> | null >>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ordersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ordersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'orders'> extends True ? CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>> : CheckSelect<T, Prisma__ordersClient<orders | null >, Prisma__ordersClient<ordersGetPayload<T> | null >>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `OrderID`
     * const ordersWithOrderIDOnly = await prisma.orders.findMany({ select: { OrderID: true } })
     * 
    **/
    findMany<T extends ordersFindManyArgs>(
      args?: SelectSubset<T, ordersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<orders>>, PrismaPromise<Array<ordersGetPayload<T>>>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
    **/
    create<T extends ordersCreateArgs>(
      args: SelectSubset<T, ordersCreateArgs>
    ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
    **/
    delete<T extends ordersDeleteArgs>(
      args: SelectSubset<T, ordersDeleteArgs>
    ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ordersUpdateArgs>(
      args: SelectSubset<T, ordersUpdateArgs>
    ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ordersDeleteManyArgs>(
      args?: SelectSubset<T, ordersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ordersUpdateManyArgs>(
      args: SelectSubset<T, ordersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
    **/
    upsert<T extends ordersUpsertArgs>(
      args: SelectSubset<T, ordersUpsertArgs>
    ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): PrismaPromise<GetOrdersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ordersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customers<T extends customersArgs = {}>(args?: Subset<T, customersArgs>): CheckSelect<T, Prisma__customersClient<customers | null >, Prisma__customersClient<customersGetPayload<T> | null >>;

    employees<T extends employeesArgs = {}>(args?: Subset<T, employeesArgs>): CheckSelect<T, Prisma__employeesClient<employees | null >, Prisma__employeesClient<employeesGetPayload<T> | null >>;

    shippers<T extends shippersArgs = {}>(args?: Subset<T, shippersArgs>): CheckSelect<T, Prisma__shippersClient<shippers | null >, Prisma__shippersClient<shippersGetPayload<T> | null >>;

    orderdetails<T extends orderdetailsArgs = {}>(args?: Subset<T, orderdetailsArgs>): CheckSelect<T, Prisma__orderdetailsClient<orderdetails | null >, Prisma__orderdetailsClient<orderdetailsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * Throw an Error if a orders can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orders to fetch.
    **/
    where: ordersWhereUniqueInput
  }


  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * Throw an Error if a orders can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orders to fetch.
    **/
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
    **/
    orderBy?: Enumerable<ordersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
    **/
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
    **/
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * orders findMany
   */
  export type ordersFindManyArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
    **/
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
    **/
    orderBy?: Enumerable<ordersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
    **/
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
    **/
    skip?: number
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * orders create
   */
  export type ordersCreateArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * The data needed to create a orders.
    **/
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }


  /**
   * orders update
   */
  export type ordersUpdateArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * The data needed to update a orders.
    **/
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
    **/
    where: ordersWhereUniqueInput
  }


  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs = {
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    where?: ordersWhereInput
  }


  /**
   * orders upsert
   */
  export type ordersUpsertArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * The filter to search for the orders to update in case it exists.
    **/
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
    **/
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }


  /**
   * orders delete
   */
  export type ordersDeleteArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
    /**
     * Filter which orders to delete.
    **/
    where: ordersWhereUniqueInput
  }


  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs = {
    where?: ordersWhereInput
  }


  /**
   * orders without action
   */
  export type ordersArgs = {
    /**
     * Select specific fields to fetch from the orders
    **/
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ordersInclude | null
  }



  /**
   * Model products
   */


  export type AggregateProducts = {
    count: ProductsCountAggregateOutputType | null
    avg: ProductsAvgAggregateOutputType | null
    sum: ProductsSumAggregateOutputType | null
    min: ProductsMinAggregateOutputType | null
    max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    ProductID: number
    SupplierID: number | null
    CategoryID: number | null
    UnitPrice: Decimal | null
    UnitsInStock: number | null
    UnitsOnOrder: number | null
    ReorderLevel: number | null
  }

  export type ProductsSumAggregateOutputType = {
    ProductID: number
    SupplierID: number | null
    CategoryID: number | null
    UnitPrice: Decimal | null
    UnitsInStock: number | null
    UnitsOnOrder: number | null
    ReorderLevel: number | null
  }

  export type ProductsMinAggregateOutputType = {
    ProductID: number
    ProductName: string | null
    SupplierID: number | null
    CategoryID: number | null
    QuantityPerUnit: string | null
    UnitPrice: Decimal | null
    UnitsInStock: number | null
    UnitsOnOrder: number | null
    ReorderLevel: number | null
    Discontinued: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    ProductID: number
    ProductName: string | null
    SupplierID: number | null
    CategoryID: number | null
    QuantityPerUnit: string | null
    UnitPrice: Decimal | null
    UnitsInStock: number | null
    UnitsOnOrder: number | null
    ReorderLevel: number | null
    Discontinued: string | null
  }

  export type ProductsCountAggregateOutputType = {
    ProductID: number
    ProductName: number | null
    SupplierID: number | null
    CategoryID: number | null
    QuantityPerUnit: number | null
    UnitPrice: number | null
    UnitsInStock: number | null
    UnitsOnOrder: number | null
    ReorderLevel: number | null
    Discontinued: number | null
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    ProductID?: true
    SupplierID?: true
    CategoryID?: true
    UnitPrice?: true
    UnitsInStock?: true
    UnitsOnOrder?: true
    ReorderLevel?: true
  }

  export type ProductsSumAggregateInputType = {
    ProductID?: true
    SupplierID?: true
    CategoryID?: true
    UnitPrice?: true
    UnitsInStock?: true
    UnitsOnOrder?: true
    ReorderLevel?: true
  }

  export type ProductsMinAggregateInputType = {
    ProductID?: true
    ProductName?: true
    SupplierID?: true
    CategoryID?: true
    QuantityPerUnit?: true
    UnitPrice?: true
    UnitsInStock?: true
    UnitsOnOrder?: true
    ReorderLevel?: true
    Discontinued?: true
  }

  export type ProductsMaxAggregateInputType = {
    ProductID?: true
    ProductName?: true
    SupplierID?: true
    CategoryID?: true
    QuantityPerUnit?: true
    UnitPrice?: true
    UnitsInStock?: true
    UnitsOnOrder?: true
    ReorderLevel?: true
    Discontinued?: true
  }

  export type ProductsCountAggregateInputType = {
    ProductID?: true
    ProductName?: true
    SupplierID?: true
    CategoryID?: true
    QuantityPerUnit?: true
    UnitPrice?: true
    UnitsInStock?: true
    UnitsOnOrder?: true
    ReorderLevel?: true
    Discontinued?: true
    _all?: true
  }

  export type ProductsAggregateArgs = {
    /**
     * Filter which products to aggregate.
    **/
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
    **/
    orderBy?: Enumerable<productsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
    [P in keyof T & keyof AggregateProducts]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }



  export type productsSelect = {
    ProductID?: boolean
    ProductName?: boolean
    SupplierID?: boolean
    CategoryID?: boolean
    QuantityPerUnit?: boolean
    UnitPrice?: boolean
    UnitsInStock?: boolean
    UnitsOnOrder?: boolean
    ReorderLevel?: boolean
    Discontinued?: boolean
    category?: boolean | categoriesArgs
    supplier?: boolean | suppliersArgs
    orderdetails?: boolean | orderdetailsFindManyArgs
  }

  export type productsInclude = {
    category?: boolean | categoriesArgs
    supplier?: boolean | suppliersArgs
    orderdetails?: boolean | orderdetailsFindManyArgs
  }

  export type productsGetPayload<
    S extends boolean | null | undefined | productsArgs,
    U = keyof S
      > = S extends true
        ? products
    : S extends undefined
    ? never
    : S extends productsArgs | productsFindManyArgs
    ?'include' extends U
    ? products  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'category'
        ? categoriesGetPayload<S['include'][P]> | null :
        P extends 'supplier'
        ? suppliersGetPayload<S['include'][P]> | null :
        P extends 'orderdetails'
        ? Array < orderdetailsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof products ?products [P]
  : 
          P extends 'category'
        ? categoriesGetPayload<S['select'][P]> | null :
        P extends 'supplier'
        ? suppliersGetPayload<S['select'][P]> | null :
        P extends 'orderdetails'
        ? Array < orderdetailsGetPayload<S['select'][P]>>  : never
  } 
    : products
  : products


  type productsCountArgs = Merge<
    Omit<productsFindManyArgs, 'select' | 'include'> & {
      select?: ProductsCountAggregateInputType | true
    }
  >

  export interface productsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, productsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'products'> extends True ? CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>> : CheckSelect<T, Prisma__productsClient<products | null >, Prisma__productsClient<productsGetPayload<T> | null >>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, productsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'products'> extends True ? CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>> : CheckSelect<T, Prisma__productsClient<products | null >, Prisma__productsClient<productsGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `ProductID`
     * const productsWithProductIDOnly = await prisma.products.findMany({ select: { ProductID: true } })
     * 
    **/
    findMany<T extends productsFindManyArgs>(
      args?: SelectSubset<T, productsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<products>>, PrismaPromise<Array<productsGetPayload<T>>>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
    **/
    create<T extends productsCreateArgs>(
      args: SelectSubset<T, productsCreateArgs>
    ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
    **/
    delete<T extends productsDeleteArgs>(
      args: SelectSubset<T, productsDeleteArgs>
    ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productsUpdateArgs>(
      args: SelectSubset<T, productsUpdateArgs>
    ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productsDeleteManyArgs>(
      args?: SelectSubset<T, productsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productsUpdateManyArgs>(
      args: SelectSubset<T, productsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
    **/
    upsert<T extends productsUpsertArgs>(
      args: SelectSubset<T, productsUpsertArgs>
    ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): PrismaPromise<GetProductsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__productsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    category<T extends categoriesArgs = {}>(args?: Subset<T, categoriesArgs>): CheckSelect<T, Prisma__categoriesClient<categories | null >, Prisma__categoriesClient<categoriesGetPayload<T> | null >>;

    supplier<T extends suppliersArgs = {}>(args?: Subset<T, suppliersArgs>): CheckSelect<T, Prisma__suppliersClient<suppliers | null >, Prisma__suppliersClient<suppliersGetPayload<T> | null >>;

    orderdetails<T extends orderdetailsFindManyArgs = {}>(args?: Subset<T, orderdetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orderdetails>>, PrismaPromise<Array<orderdetailsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * products findUnique
   */
  export type productsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * Throw an Error if a products can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which products to fetch.
    **/
    where: productsWhereUniqueInput
  }


  /**
   * products findFirst
   */
  export type productsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * Throw an Error if a products can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which products to fetch.
    **/
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
    **/
    orderBy?: Enumerable<productsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
    **/
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
    **/
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * products findMany
   */
  export type productsFindManyArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * Filter, which products to fetch.
    **/
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
    **/
    orderBy?: Enumerable<productsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
    **/
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
    **/
    skip?: number
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * products create
   */
  export type productsCreateArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * The data needed to create a products.
    **/
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }


  /**
   * products update
   */
  export type productsUpdateArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * The data needed to update a products.
    **/
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
    **/
    where: productsWhereUniqueInput
  }


  /**
   * products updateMany
   */
  export type productsUpdateManyArgs = {
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    where?: productsWhereInput
  }


  /**
   * products upsert
   */
  export type productsUpsertArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * The filter to search for the products to update in case it exists.
    **/
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
    **/
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }


  /**
   * products delete
   */
  export type productsDeleteArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
    /**
     * Filter which products to delete.
    **/
    where: productsWhereUniqueInput
  }


  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs = {
    where?: productsWhereInput
  }


  /**
   * products without action
   */
  export type productsArgs = {
    /**
     * Select specific fields to fetch from the products
    **/
    select?: productsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: productsInclude | null
  }



  /**
   * Model regions
   */


  export type AggregateRegions = {
    count: RegionsCountAggregateOutputType | null
    avg: RegionsAvgAggregateOutputType | null
    sum: RegionsSumAggregateOutputType | null
    min: RegionsMinAggregateOutputType | null
    max: RegionsMaxAggregateOutputType | null
  }

  export type RegionsAvgAggregateOutputType = {
    RegionID: number
  }

  export type RegionsSumAggregateOutputType = {
    RegionID: number
  }

  export type RegionsMinAggregateOutputType = {
    RegionID: number
    RegionDescription: string | null
  }

  export type RegionsMaxAggregateOutputType = {
    RegionID: number
    RegionDescription: string | null
  }

  export type RegionsCountAggregateOutputType = {
    RegionID: number
    RegionDescription: number | null
    _all: number
  }


  export type RegionsAvgAggregateInputType = {
    RegionID?: true
  }

  export type RegionsSumAggregateInputType = {
    RegionID?: true
  }

  export type RegionsMinAggregateInputType = {
    RegionID?: true
    RegionDescription?: true
  }

  export type RegionsMaxAggregateInputType = {
    RegionID?: true
    RegionDescription?: true
  }

  export type RegionsCountAggregateInputType = {
    RegionID?: true
    RegionDescription?: true
    _all?: true
  }

  export type RegionsAggregateArgs = {
    /**
     * Filter which regions to aggregate.
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
    **/
    orderBy?: Enumerable<regionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regions
    **/
    count?: true | RegionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RegionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RegionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RegionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RegionsMaxAggregateInputType
  }

  export type GetRegionsAggregateType<T extends RegionsAggregateArgs> = {
    [P in keyof T & keyof AggregateRegions]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegions[P]>
      : GetScalarType<T[P], AggregateRegions[P]>
  }



  export type regionsSelect = {
    RegionID?: boolean
    RegionDescription?: boolean
    territories?: boolean | territoriesFindManyArgs
  }

  export type regionsInclude = {
    territories?: boolean | territoriesFindManyArgs
  }

  export type regionsGetPayload<
    S extends boolean | null | undefined | regionsArgs,
    U = keyof S
      > = S extends true
        ? regions
    : S extends undefined
    ? never
    : S extends regionsArgs | regionsFindManyArgs
    ?'include' extends U
    ? regions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'territories'
        ? Array < territoriesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof regions ?regions [P]
  : 
          P extends 'territories'
        ? Array < territoriesGetPayload<S['select'][P]>>  : never
  } 
    : regions
  : regions


  type regionsCountArgs = Merge<
    Omit<regionsFindManyArgs, 'select' | 'include'> & {
      select?: RegionsCountAggregateInputType | true
    }
  >

  export interface regionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Regions that matches the filter.
     * @param {regionsFindUniqueArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regions'> extends True ? CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>> : CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>

    /**
     * Find the first Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsFindFirstArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regions'> extends True ? CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>> : CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.regions.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.regions.findMany({ take: 10 })
     * 
     * // Only select the `RegionID`
     * const regionsWithRegionIDOnly = await prisma.regions.findMany({ select: { RegionID: true } })
     * 
    **/
    findMany<T extends regionsFindManyArgs>(
      args?: SelectSubset<T, regionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<regions>>, PrismaPromise<Array<regionsGetPayload<T>>>>

    /**
     * Create a Regions.
     * @param {regionsCreateArgs} args - Arguments to create a Regions.
     * @example
     * // Create one Regions
     * const Regions = await prisma.regions.create({
     *   data: {
     *     // ... data to create a Regions
     *   }
     * })
     * 
    **/
    create<T extends regionsCreateArgs>(
      args: SelectSubset<T, regionsCreateArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Delete a Regions.
     * @param {regionsDeleteArgs} args - Arguments to delete one Regions.
     * @example
     * // Delete one Regions
     * const Regions = await prisma.regions.delete({
     *   where: {
     *     // ... filter to delete one Regions
     *   }
     * })
     * 
    **/
    delete<T extends regionsDeleteArgs>(
      args: SelectSubset<T, regionsDeleteArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Update one Regions.
     * @param {regionsUpdateArgs} args - Arguments to update one Regions.
     * @example
     * // Update one Regions
     * const regions = await prisma.regions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regionsUpdateArgs>(
      args: SelectSubset<T, regionsUpdateArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {regionsDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.regions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regionsDeleteManyArgs>(
      args?: SelectSubset<T, regionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const regions = await prisma.regions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regionsUpdateManyArgs>(
      args: SelectSubset<T, regionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regions.
     * @param {regionsUpsertArgs} args - Arguments to update or create a Regions.
     * @example
     * // Update or create a Regions
     * const regions = await prisma.regions.upsert({
     *   create: {
     *     // ... data to create a Regions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regions we want to update
     *   }
     * })
    **/
    upsert<T extends regionsUpsertArgs>(
      args: SelectSubset<T, regionsUpsertArgs>
    ): CheckSelect<T, Prisma__regionsClient<regions>, Prisma__regionsClient<regionsGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regionsCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.regions.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends regionsCountArgs>(
      args?: Subset<T, regionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionsAggregateArgs>(args: Subset<T, RegionsAggregateArgs>): PrismaPromise<GetRegionsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for regions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    territories<T extends territoriesFindManyArgs = {}>(args?: Subset<T, territoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<territories>>, PrismaPromise<Array<territoriesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * regions findUnique
   */
  export type regionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * Throw an Error if a regions can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which regions to fetch.
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions findFirst
   */
  export type regionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * Throw an Error if a regions can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which regions to fetch.
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
    **/
    orderBy?: Enumerable<regionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regions.
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regions.
    **/
    distinct?: Enumerable<RegionsScalarFieldEnum>
  }


  /**
   * regions findMany
   */
  export type regionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * Filter, which regions to fetch.
    **/
    where?: regionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regions to fetch.
    **/
    orderBy?: Enumerable<regionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regions.
    **/
    cursor?: regionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regions.
    **/
    skip?: number
    distinct?: Enumerable<RegionsScalarFieldEnum>
  }


  /**
   * regions create
   */
  export type regionsCreateArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * The data needed to create a regions.
    **/
    data: XOR<regionsCreateInput, regionsUncheckedCreateInput>
  }


  /**
   * regions update
   */
  export type regionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * The data needed to update a regions.
    **/
    data: XOR<regionsUpdateInput, regionsUncheckedUpdateInput>
    /**
     * Choose, which regions to update.
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions updateMany
   */
  export type regionsUpdateManyArgs = {
    data: XOR<regionsUpdateManyMutationInput, regionsUncheckedUpdateManyInput>
    where?: regionsWhereInput
  }


  /**
   * regions upsert
   */
  export type regionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * The filter to search for the regions to update in case it exists.
    **/
    where: regionsWhereUniqueInput
    /**
     * In case the regions found by the `where` argument doesn't exist, create a new regions with this data.
    **/
    create: XOR<regionsCreateInput, regionsUncheckedCreateInput>
    /**
     * In case the regions was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<regionsUpdateInput, regionsUncheckedUpdateInput>
  }


  /**
   * regions delete
   */
  export type regionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
    /**
     * Filter which regions to delete.
    **/
    where: regionsWhereUniqueInput
  }


  /**
   * regions deleteMany
   */
  export type regionsDeleteManyArgs = {
    where?: regionsWhereInput
  }


  /**
   * regions without action
   */
  export type regionsArgs = {
    /**
     * Select specific fields to fetch from the regions
    **/
    select?: regionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: regionsInclude | null
  }



  /**
   * Model shippers
   */


  export type AggregateShippers = {
    count: ShippersCountAggregateOutputType | null
    avg: ShippersAvgAggregateOutputType | null
    sum: ShippersSumAggregateOutputType | null
    min: ShippersMinAggregateOutputType | null
    max: ShippersMaxAggregateOutputType | null
  }

  export type ShippersAvgAggregateOutputType = {
    ShipperID: number
  }

  export type ShippersSumAggregateOutputType = {
    ShipperID: number
  }

  export type ShippersMinAggregateOutputType = {
    ShipperID: number
    CompanyName: string | null
    Phone: string | null
  }

  export type ShippersMaxAggregateOutputType = {
    ShipperID: number
    CompanyName: string | null
    Phone: string | null
  }

  export type ShippersCountAggregateOutputType = {
    ShipperID: number
    CompanyName: number | null
    Phone: number | null
    _all: number
  }


  export type ShippersAvgAggregateInputType = {
    ShipperID?: true
  }

  export type ShippersSumAggregateInputType = {
    ShipperID?: true
  }

  export type ShippersMinAggregateInputType = {
    ShipperID?: true
    CompanyName?: true
    Phone?: true
  }

  export type ShippersMaxAggregateInputType = {
    ShipperID?: true
    CompanyName?: true
    Phone?: true
  }

  export type ShippersCountAggregateInputType = {
    ShipperID?: true
    CompanyName?: true
    Phone?: true
    _all?: true
  }

  export type ShippersAggregateArgs = {
    /**
     * Filter which shippers to aggregate.
    **/
    where?: shippersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shippers to fetch.
    **/
    orderBy?: Enumerable<shippersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: shippersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shippers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shippers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shippers
    **/
    count?: true | ShippersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ShippersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ShippersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ShippersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ShippersMaxAggregateInputType
  }

  export type GetShippersAggregateType<T extends ShippersAggregateArgs> = {
    [P in keyof T & keyof AggregateShippers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippers[P]>
      : GetScalarType<T[P], AggregateShippers[P]>
  }



  export type shippersSelect = {
    ShipperID?: boolean
    CompanyName?: boolean
    Phone?: boolean
    orders?: boolean | ordersFindManyArgs
  }

  export type shippersInclude = {
    orders?: boolean | ordersFindManyArgs
  }

  export type shippersGetPayload<
    S extends boolean | null | undefined | shippersArgs,
    U = keyof S
      > = S extends true
        ? shippers
    : S extends undefined
    ? never
    : S extends shippersArgs | shippersFindManyArgs
    ?'include' extends U
    ? shippers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'orders'
        ? Array < ordersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof shippers ?shippers [P]
  : 
          P extends 'orders'
        ? Array < ordersGetPayload<S['select'][P]>>  : never
  } 
    : shippers
  : shippers


  type shippersCountArgs = Merge<
    Omit<shippersFindManyArgs, 'select' | 'include'> & {
      select?: ShippersCountAggregateInputType | true
    }
  >

  export interface shippersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Shippers that matches the filter.
     * @param {shippersFindUniqueArgs} args - Arguments to find a Shippers
     * @example
     * // Get one Shippers
     * const shippers = await prisma.shippers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shippersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shippersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'shippers'> extends True ? CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>> : CheckSelect<T, Prisma__shippersClient<shippers | null >, Prisma__shippersClient<shippersGetPayload<T> | null >>

    /**
     * Find the first Shippers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shippersFindFirstArgs} args - Arguments to find a Shippers
     * @example
     * // Get one Shippers
     * const shippers = await prisma.shippers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shippersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shippersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'shippers'> extends True ? CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>> : CheckSelect<T, Prisma__shippersClient<shippers | null >, Prisma__shippersClient<shippersGetPayload<T> | null >>

    /**
     * Find zero or more Shippers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shippersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shippers
     * const shippers = await prisma.shippers.findMany()
     * 
     * // Get first 10 Shippers
     * const shippers = await prisma.shippers.findMany({ take: 10 })
     * 
     * // Only select the `ShipperID`
     * const shippersWithShipperIDOnly = await prisma.shippers.findMany({ select: { ShipperID: true } })
     * 
    **/
    findMany<T extends shippersFindManyArgs>(
      args?: SelectSubset<T, shippersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<shippers>>, PrismaPromise<Array<shippersGetPayload<T>>>>

    /**
     * Create a Shippers.
     * @param {shippersCreateArgs} args - Arguments to create a Shippers.
     * @example
     * // Create one Shippers
     * const Shippers = await prisma.shippers.create({
     *   data: {
     *     // ... data to create a Shippers
     *   }
     * })
     * 
    **/
    create<T extends shippersCreateArgs>(
      args: SelectSubset<T, shippersCreateArgs>
    ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>

    /**
     * Delete a Shippers.
     * @param {shippersDeleteArgs} args - Arguments to delete one Shippers.
     * @example
     * // Delete one Shippers
     * const Shippers = await prisma.shippers.delete({
     *   where: {
     *     // ... filter to delete one Shippers
     *   }
     * })
     * 
    **/
    delete<T extends shippersDeleteArgs>(
      args: SelectSubset<T, shippersDeleteArgs>
    ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>

    /**
     * Update one Shippers.
     * @param {shippersUpdateArgs} args - Arguments to update one Shippers.
     * @example
     * // Update one Shippers
     * const shippers = await prisma.shippers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shippersUpdateArgs>(
      args: SelectSubset<T, shippersUpdateArgs>
    ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>

    /**
     * Delete zero or more Shippers.
     * @param {shippersDeleteManyArgs} args - Arguments to filter Shippers to delete.
     * @example
     * // Delete a few Shippers
     * const { count } = await prisma.shippers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shippersDeleteManyArgs>(
      args?: SelectSubset<T, shippersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shippers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shippersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shippers
     * const shippers = await prisma.shippers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shippersUpdateManyArgs>(
      args: SelectSubset<T, shippersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Shippers.
     * @param {shippersUpsertArgs} args - Arguments to update or create a Shippers.
     * @example
     * // Update or create a Shippers
     * const shippers = await prisma.shippers.upsert({
     *   create: {
     *     // ... data to create a Shippers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shippers we want to update
     *   }
     * })
    **/
    upsert<T extends shippersUpsertArgs>(
      args: SelectSubset<T, shippersUpsertArgs>
    ): CheckSelect<T, Prisma__shippersClient<shippers>, Prisma__shippersClient<shippersGetPayload<T>>>

    /**
     * Count the number of Shippers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shippersCountArgs} args - Arguments to filter Shippers to count.
     * @example
     * // Count the number of Shippers
     * const count = await prisma.shippers.count({
     *   where: {
     *     // ... the filter for the Shippers we want to count
     *   }
     * })
    **/
    count<T extends shippersCountArgs>(
      args?: Subset<T, shippersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shippers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippersAggregateArgs>(args: Subset<T, ShippersAggregateArgs>): PrismaPromise<GetShippersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for shippers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shippersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orders<T extends ordersFindManyArgs = {}>(args?: Subset<T, ordersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orders>>, PrismaPromise<Array<ordersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * shippers findUnique
   */
  export type shippersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * Throw an Error if a shippers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which shippers to fetch.
    **/
    where: shippersWhereUniqueInput
  }


  /**
   * shippers findFirst
   */
  export type shippersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * Throw an Error if a shippers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which shippers to fetch.
    **/
    where?: shippersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shippers to fetch.
    **/
    orderBy?: Enumerable<shippersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shippers.
    **/
    cursor?: shippersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shippers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shippers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shippers.
    **/
    distinct?: Enumerable<ShippersScalarFieldEnum>
  }


  /**
   * shippers findMany
   */
  export type shippersFindManyArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * Filter, which shippers to fetch.
    **/
    where?: shippersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shippers to fetch.
    **/
    orderBy?: Enumerable<shippersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shippers.
    **/
    cursor?: shippersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shippers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shippers.
    **/
    skip?: number
    distinct?: Enumerable<ShippersScalarFieldEnum>
  }


  /**
   * shippers create
   */
  export type shippersCreateArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * The data needed to create a shippers.
    **/
    data: XOR<shippersCreateInput, shippersUncheckedCreateInput>
  }


  /**
   * shippers update
   */
  export type shippersUpdateArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * The data needed to update a shippers.
    **/
    data: XOR<shippersUpdateInput, shippersUncheckedUpdateInput>
    /**
     * Choose, which shippers to update.
    **/
    where: shippersWhereUniqueInput
  }


  /**
   * shippers updateMany
   */
  export type shippersUpdateManyArgs = {
    data: XOR<shippersUpdateManyMutationInput, shippersUncheckedUpdateManyInput>
    where?: shippersWhereInput
  }


  /**
   * shippers upsert
   */
  export type shippersUpsertArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * The filter to search for the shippers to update in case it exists.
    **/
    where: shippersWhereUniqueInput
    /**
     * In case the shippers found by the `where` argument doesn't exist, create a new shippers with this data.
    **/
    create: XOR<shippersCreateInput, shippersUncheckedCreateInput>
    /**
     * In case the shippers was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<shippersUpdateInput, shippersUncheckedUpdateInput>
  }


  /**
   * shippers delete
   */
  export type shippersDeleteArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
    /**
     * Filter which shippers to delete.
    **/
    where: shippersWhereUniqueInput
  }


  /**
   * shippers deleteMany
   */
  export type shippersDeleteManyArgs = {
    where?: shippersWhereInput
  }


  /**
   * shippers without action
   */
  export type shippersArgs = {
    /**
     * Select specific fields to fetch from the shippers
    **/
    select?: shippersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: shippersInclude | null
  }



  /**
   * Model suppliers
   */


  export type AggregateSuppliers = {
    count: SuppliersCountAggregateOutputType | null
    avg: SuppliersAvgAggregateOutputType | null
    sum: SuppliersSumAggregateOutputType | null
    min: SuppliersMinAggregateOutputType | null
    max: SuppliersMaxAggregateOutputType | null
  }

  export type SuppliersAvgAggregateOutputType = {
    SupplierID: number
  }

  export type SuppliersSumAggregateOutputType = {
    SupplierID: number
  }

  export type SuppliersMinAggregateOutputType = {
    SupplierID: number
    CompanyName: string | null
    ContactName: string | null
    ContactTitle: string | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    Phone: string | null
    Fax: string | null
    HomePage: string | null
  }

  export type SuppliersMaxAggregateOutputType = {
    SupplierID: number
    CompanyName: string | null
    ContactName: string | null
    ContactTitle: string | null
    Address: string | null
    City: string | null
    Region: string | null
    PostalCode: string | null
    Country: string | null
    Phone: string | null
    Fax: string | null
    HomePage: string | null
  }

  export type SuppliersCountAggregateOutputType = {
    SupplierID: number
    CompanyName: number | null
    ContactName: number | null
    ContactTitle: number | null
    Address: number | null
    City: number | null
    Region: number | null
    PostalCode: number | null
    Country: number | null
    Phone: number | null
    Fax: number | null
    HomePage: number | null
    _all: number
  }


  export type SuppliersAvgAggregateInputType = {
    SupplierID?: true
  }

  export type SuppliersSumAggregateInputType = {
    SupplierID?: true
  }

  export type SuppliersMinAggregateInputType = {
    SupplierID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
    HomePage?: true
  }

  export type SuppliersMaxAggregateInputType = {
    SupplierID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
    HomePage?: true
  }

  export type SuppliersCountAggregateInputType = {
    SupplierID?: true
    CompanyName?: true
    ContactName?: true
    ContactTitle?: true
    Address?: true
    City?: true
    Region?: true
    PostalCode?: true
    Country?: true
    Phone?: true
    Fax?: true
    HomePage?: true
    _all?: true
  }

  export type SuppliersAggregateArgs = {
    /**
     * Filter which suppliers to aggregate.
    **/
    where?: suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<suppliersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    count?: true | SuppliersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SuppliersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SuppliersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SuppliersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SuppliersMaxAggregateInputType
  }

  export type GetSuppliersAggregateType<T extends SuppliersAggregateArgs> = {
    [P in keyof T & keyof AggregateSuppliers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuppliers[P]>
      : GetScalarType<T[P], AggregateSuppliers[P]>
  }



  export type suppliersSelect = {
    SupplierID?: boolean
    CompanyName?: boolean
    ContactName?: boolean
    ContactTitle?: boolean
    Address?: boolean
    City?: boolean
    Region?: boolean
    PostalCode?: boolean
    Country?: boolean
    Phone?: boolean
    Fax?: boolean
    HomePage?: boolean
    products?: boolean | productsFindManyArgs
  }

  export type suppliersInclude = {
    products?: boolean | productsFindManyArgs
  }

  export type suppliersGetPayload<
    S extends boolean | null | undefined | suppliersArgs,
    U = keyof S
      > = S extends true
        ? suppliers
    : S extends undefined
    ? never
    : S extends suppliersArgs | suppliersFindManyArgs
    ?'include' extends U
    ? suppliers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < productsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof suppliers ?suppliers [P]
  : 
          P extends 'products'
        ? Array < productsGetPayload<S['select'][P]>>  : never
  } 
    : suppliers
  : suppliers


  type suppliersCountArgs = Merge<
    Omit<suppliersFindManyArgs, 'select' | 'include'> & {
      select?: SuppliersCountAggregateInputType | true
    }
  >

  export interface suppliersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Suppliers that matches the filter.
     * @param {suppliersFindUniqueArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends suppliersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, suppliersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'suppliers'> extends True ? CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>> : CheckSelect<T, Prisma__suppliersClient<suppliers | null >, Prisma__suppliersClient<suppliersGetPayload<T> | null >>

    /**
     * Find the first Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suppliersFindFirstArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends suppliersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, suppliersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'suppliers'> extends True ? CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>> : CheckSelect<T, Prisma__suppliersClient<suppliers | null >, Prisma__suppliersClient<suppliersGetPayload<T> | null >>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suppliersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.suppliers.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.suppliers.findMany({ take: 10 })
     * 
     * // Only select the `SupplierID`
     * const suppliersWithSupplierIDOnly = await prisma.suppliers.findMany({ select: { SupplierID: true } })
     * 
    **/
    findMany<T extends suppliersFindManyArgs>(
      args?: SelectSubset<T, suppliersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<suppliers>>, PrismaPromise<Array<suppliersGetPayload<T>>>>

    /**
     * Create a Suppliers.
     * @param {suppliersCreateArgs} args - Arguments to create a Suppliers.
     * @example
     * // Create one Suppliers
     * const Suppliers = await prisma.suppliers.create({
     *   data: {
     *     // ... data to create a Suppliers
     *   }
     * })
     * 
    **/
    create<T extends suppliersCreateArgs>(
      args: SelectSubset<T, suppliersCreateArgs>
    ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>

    /**
     * Delete a Suppliers.
     * @param {suppliersDeleteArgs} args - Arguments to delete one Suppliers.
     * @example
     * // Delete one Suppliers
     * const Suppliers = await prisma.suppliers.delete({
     *   where: {
     *     // ... filter to delete one Suppliers
     *   }
     * })
     * 
    **/
    delete<T extends suppliersDeleteArgs>(
      args: SelectSubset<T, suppliersDeleteArgs>
    ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>

    /**
     * Update one Suppliers.
     * @param {suppliersUpdateArgs} args - Arguments to update one Suppliers.
     * @example
     * // Update one Suppliers
     * const suppliers = await prisma.suppliers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends suppliersUpdateArgs>(
      args: SelectSubset<T, suppliersUpdateArgs>
    ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>

    /**
     * Delete zero or more Suppliers.
     * @param {suppliersDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.suppliers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends suppliersDeleteManyArgs>(
      args?: SelectSubset<T, suppliersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suppliersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const suppliers = await prisma.suppliers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends suppliersUpdateManyArgs>(
      args: SelectSubset<T, suppliersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Suppliers.
     * @param {suppliersUpsertArgs} args - Arguments to update or create a Suppliers.
     * @example
     * // Update or create a Suppliers
     * const suppliers = await prisma.suppliers.upsert({
     *   create: {
     *     // ... data to create a Suppliers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suppliers we want to update
     *   }
     * })
    **/
    upsert<T extends suppliersUpsertArgs>(
      args: SelectSubset<T, suppliersUpsertArgs>
    ): CheckSelect<T, Prisma__suppliersClient<suppliers>, Prisma__suppliersClient<suppliersGetPayload<T>>>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suppliersCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.suppliers.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends suppliersCountArgs>(
      args?: Subset<T, suppliersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuppliersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuppliersAggregateArgs>(args: Subset<T, SuppliersAggregateArgs>): PrismaPromise<GetSuppliersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for suppliers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__suppliersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends productsFindManyArgs = {}>(args?: Subset<T, productsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<products>>, PrismaPromise<Array<productsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * suppliers findUnique
   */
  export type suppliersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * Throw an Error if a suppliers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which suppliers to fetch.
    **/
    where: suppliersWhereUniqueInput
  }


  /**
   * suppliers findFirst
   */
  export type suppliersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * Throw an Error if a suppliers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which suppliers to fetch.
    **/
    where?: suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<suppliersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
    **/
    cursor?: suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
    **/
    distinct?: Enumerable<SuppliersScalarFieldEnum>
  }


  /**
   * suppliers findMany
   */
  export type suppliersFindManyArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * Filter, which suppliers to fetch.
    **/
    where?: suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
    **/
    orderBy?: Enumerable<suppliersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
    **/
    cursor?: suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
    **/
    skip?: number
    distinct?: Enumerable<SuppliersScalarFieldEnum>
  }


  /**
   * suppliers create
   */
  export type suppliersCreateArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * The data needed to create a suppliers.
    **/
    data: XOR<suppliersCreateInput, suppliersUncheckedCreateInput>
  }


  /**
   * suppliers update
   */
  export type suppliersUpdateArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * The data needed to update a suppliers.
    **/
    data: XOR<suppliersUpdateInput, suppliersUncheckedUpdateInput>
    /**
     * Choose, which suppliers to update.
    **/
    where: suppliersWhereUniqueInput
  }


  /**
   * suppliers updateMany
   */
  export type suppliersUpdateManyArgs = {
    data: XOR<suppliersUpdateManyMutationInput, suppliersUncheckedUpdateManyInput>
    where?: suppliersWhereInput
  }


  /**
   * suppliers upsert
   */
  export type suppliersUpsertArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * The filter to search for the suppliers to update in case it exists.
    **/
    where: suppliersWhereUniqueInput
    /**
     * In case the suppliers found by the `where` argument doesn't exist, create a new suppliers with this data.
    **/
    create: XOR<suppliersCreateInput, suppliersUncheckedCreateInput>
    /**
     * In case the suppliers was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<suppliersUpdateInput, suppliersUncheckedUpdateInput>
  }


  /**
   * suppliers delete
   */
  export type suppliersDeleteArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
    /**
     * Filter which suppliers to delete.
    **/
    where: suppliersWhereUniqueInput
  }


  /**
   * suppliers deleteMany
   */
  export type suppliersDeleteManyArgs = {
    where?: suppliersWhereInput
  }


  /**
   * suppliers without action
   */
  export type suppliersArgs = {
    /**
     * Select specific fields to fetch from the suppliers
    **/
    select?: suppliersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: suppliersInclude | null
  }



  /**
   * Model territories
   */


  export type AggregateTerritories = {
    count: TerritoriesCountAggregateOutputType | null
    avg: TerritoriesAvgAggregateOutputType | null
    sum: TerritoriesSumAggregateOutputType | null
    min: TerritoriesMinAggregateOutputType | null
    max: TerritoriesMaxAggregateOutputType | null
  }

  export type TerritoriesAvgAggregateOutputType = {
    RegionID: number | null
  }

  export type TerritoriesSumAggregateOutputType = {
    RegionID: number | null
  }

  export type TerritoriesMinAggregateOutputType = {
    TerritoryID: string | null
    TerritoryDescription: string | null
    RegionID: number | null
  }

  export type TerritoriesMaxAggregateOutputType = {
    TerritoryID: string | null
    TerritoryDescription: string | null
    RegionID: number | null
  }

  export type TerritoriesCountAggregateOutputType = {
    TerritoryID: number | null
    TerritoryDescription: number | null
    RegionID: number | null
    _all: number
  }


  export type TerritoriesAvgAggregateInputType = {
    RegionID?: true
  }

  export type TerritoriesSumAggregateInputType = {
    RegionID?: true
  }

  export type TerritoriesMinAggregateInputType = {
    TerritoryID?: true
    TerritoryDescription?: true
    RegionID?: true
  }

  export type TerritoriesMaxAggregateInputType = {
    TerritoryID?: true
    TerritoryDescription?: true
    RegionID?: true
  }

  export type TerritoriesCountAggregateInputType = {
    TerritoryID?: true
    TerritoryDescription?: true
    RegionID?: true
    _all?: true
  }

  export type TerritoriesAggregateArgs = {
    /**
     * Filter which territories to aggregate.
    **/
    where?: territoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of territories to fetch.
    **/
    orderBy?: Enumerable<territoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: territoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` territories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` territories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned territories
    **/
    count?: true | TerritoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TerritoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TerritoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TerritoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TerritoriesMaxAggregateInputType
  }

  export type GetTerritoriesAggregateType<T extends TerritoriesAggregateArgs> = {
    [P in keyof T & keyof AggregateTerritories]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerritories[P]>
      : GetScalarType<T[P], AggregateTerritories[P]>
  }



  export type territoriesSelect = {
    TerritoryID?: boolean
    TerritoryDescription?: boolean
    RegionID?: boolean
    regions?: boolean | regionsArgs
    employeeterritories?: boolean | employeeterritoriesFindManyArgs
  }

  export type territoriesInclude = {
    regions?: boolean | regionsArgs
    employeeterritories?: boolean | employeeterritoriesFindManyArgs
  }

  export type territoriesGetPayload<
    S extends boolean | null | undefined | territoriesArgs,
    U = keyof S
      > = S extends true
        ? territories
    : S extends undefined
    ? never
    : S extends territoriesArgs | territoriesFindManyArgs
    ?'include' extends U
    ? territories  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'regions'
        ? regionsGetPayload<S['include'][P]> | null :
        P extends 'employeeterritories'
        ? Array < employeeterritoriesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof territories ?territories [P]
  : 
          P extends 'regions'
        ? regionsGetPayload<S['select'][P]> | null :
        P extends 'employeeterritories'
        ? Array < employeeterritoriesGetPayload<S['select'][P]>>  : never
  } 
    : territories
  : territories


  type territoriesCountArgs = Merge<
    Omit<territoriesFindManyArgs, 'select' | 'include'> & {
      select?: TerritoriesCountAggregateInputType | true
    }
  >

  export interface territoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Territories that matches the filter.
     * @param {territoriesFindUniqueArgs} args - Arguments to find a Territories
     * @example
     * // Get one Territories
     * const territories = await prisma.territories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends territoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, territoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'territories'> extends True ? CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>> : CheckSelect<T, Prisma__territoriesClient<territories | null >, Prisma__territoriesClient<territoriesGetPayload<T> | null >>

    /**
     * Find the first Territories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {territoriesFindFirstArgs} args - Arguments to find a Territories
     * @example
     * // Get one Territories
     * const territories = await prisma.territories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends territoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, territoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'territories'> extends True ? CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>> : CheckSelect<T, Prisma__territoriesClient<territories | null >, Prisma__territoriesClient<territoriesGetPayload<T> | null >>

    /**
     * Find zero or more Territories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {territoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Territories
     * const territories = await prisma.territories.findMany()
     * 
     * // Get first 10 Territories
     * const territories = await prisma.territories.findMany({ take: 10 })
     * 
     * // Only select the `TerritoryID`
     * const territoriesWithTerritoryIDOnly = await prisma.territories.findMany({ select: { TerritoryID: true } })
     * 
    **/
    findMany<T extends territoriesFindManyArgs>(
      args?: SelectSubset<T, territoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<territories>>, PrismaPromise<Array<territoriesGetPayload<T>>>>

    /**
     * Create a Territories.
     * @param {territoriesCreateArgs} args - Arguments to create a Territories.
     * @example
     * // Create one Territories
     * const Territories = await prisma.territories.create({
     *   data: {
     *     // ... data to create a Territories
     *   }
     * })
     * 
    **/
    create<T extends territoriesCreateArgs>(
      args: SelectSubset<T, territoriesCreateArgs>
    ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>

    /**
     * Delete a Territories.
     * @param {territoriesDeleteArgs} args - Arguments to delete one Territories.
     * @example
     * // Delete one Territories
     * const Territories = await prisma.territories.delete({
     *   where: {
     *     // ... filter to delete one Territories
     *   }
     * })
     * 
    **/
    delete<T extends territoriesDeleteArgs>(
      args: SelectSubset<T, territoriesDeleteArgs>
    ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>

    /**
     * Update one Territories.
     * @param {territoriesUpdateArgs} args - Arguments to update one Territories.
     * @example
     * // Update one Territories
     * const territories = await prisma.territories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends territoriesUpdateArgs>(
      args: SelectSubset<T, territoriesUpdateArgs>
    ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>

    /**
     * Delete zero or more Territories.
     * @param {territoriesDeleteManyArgs} args - Arguments to filter Territories to delete.
     * @example
     * // Delete a few Territories
     * const { count } = await prisma.territories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends territoriesDeleteManyArgs>(
      args?: SelectSubset<T, territoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {territoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Territories
     * const territories = await prisma.territories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends territoriesUpdateManyArgs>(
      args: SelectSubset<T, territoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Territories.
     * @param {territoriesUpsertArgs} args - Arguments to update or create a Territories.
     * @example
     * // Update or create a Territories
     * const territories = await prisma.territories.upsert({
     *   create: {
     *     // ... data to create a Territories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Territories we want to update
     *   }
     * })
    **/
    upsert<T extends territoriesUpsertArgs>(
      args: SelectSubset<T, territoriesUpsertArgs>
    ): CheckSelect<T, Prisma__territoriesClient<territories>, Prisma__territoriesClient<territoriesGetPayload<T>>>

    /**
     * Count the number of Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {territoriesCountArgs} args - Arguments to filter Territories to count.
     * @example
     * // Count the number of Territories
     * const count = await prisma.territories.count({
     *   where: {
     *     // ... the filter for the Territories we want to count
     *   }
     * })
    **/
    count<T extends territoriesCountArgs>(
      args?: Subset<T, territoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerritoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerritoriesAggregateArgs>(args: Subset<T, TerritoriesAggregateArgs>): PrismaPromise<GetTerritoriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for territories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__territoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    regions<T extends regionsArgs = {}>(args?: Subset<T, regionsArgs>): CheckSelect<T, Prisma__regionsClient<regions | null >, Prisma__regionsClient<regionsGetPayload<T> | null >>;

    employeeterritories<T extends employeeterritoriesFindManyArgs = {}>(args?: Subset<T, employeeterritoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<employeeterritories>>, PrismaPromise<Array<employeeterritoriesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * territories findUnique
   */
  export type territoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * Throw an Error if a territories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which territories to fetch.
    **/
    where: territoriesWhereUniqueInput
  }


  /**
   * territories findFirst
   */
  export type territoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * Throw an Error if a territories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which territories to fetch.
    **/
    where?: territoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of territories to fetch.
    **/
    orderBy?: Enumerable<territoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for territories.
    **/
    cursor?: territoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` territories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` territories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of territories.
    **/
    distinct?: Enumerable<TerritoriesScalarFieldEnum>
  }


  /**
   * territories findMany
   */
  export type territoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * Filter, which territories to fetch.
    **/
    where?: territoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of territories to fetch.
    **/
    orderBy?: Enumerable<territoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing territories.
    **/
    cursor?: territoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` territories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` territories.
    **/
    skip?: number
    distinct?: Enumerable<TerritoriesScalarFieldEnum>
  }


  /**
   * territories create
   */
  export type territoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * The data needed to create a territories.
    **/
    data: XOR<territoriesCreateInput, territoriesUncheckedCreateInput>
  }


  /**
   * territories update
   */
  export type territoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * The data needed to update a territories.
    **/
    data: XOR<territoriesUpdateInput, territoriesUncheckedUpdateInput>
    /**
     * Choose, which territories to update.
    **/
    where: territoriesWhereUniqueInput
  }


  /**
   * territories updateMany
   */
  export type territoriesUpdateManyArgs = {
    data: XOR<territoriesUpdateManyMutationInput, territoriesUncheckedUpdateManyInput>
    where?: territoriesWhereInput
  }


  /**
   * territories upsert
   */
  export type territoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * The filter to search for the territories to update in case it exists.
    **/
    where: territoriesWhereUniqueInput
    /**
     * In case the territories found by the `where` argument doesn't exist, create a new territories with this data.
    **/
    create: XOR<territoriesCreateInput, territoriesUncheckedCreateInput>
    /**
     * In case the territories was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<territoriesUpdateInput, territoriesUncheckedUpdateInput>
  }


  /**
   * territories delete
   */
  export type territoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
    /**
     * Filter which territories to delete.
    **/
    where: territoriesWhereUniqueInput
  }


  /**
   * territories deleteMany
   */
  export type territoriesDeleteManyArgs = {
    where?: territoriesWhereInput
  }


  /**
   * territories without action
   */
  export type territoriesArgs = {
    /**
     * Select specific fields to fetch from the territories
    **/
    select?: territoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: territoriesInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoriesScalarFieldEnum: {
    CategoryID: 'CategoryID',
    CategoryName: 'CategoryName',
    Description: 'Description',
    Picture: 'Picture'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CustomercustomerdemoScalarFieldEnum: {
    CustomerID: 'CustomerID',
    CustomerTypeID: 'CustomerTypeID'
  };

  export type CustomercustomerdemoScalarFieldEnum = (typeof CustomercustomerdemoScalarFieldEnum)[keyof typeof CustomercustomerdemoScalarFieldEnum]


  export const CustomerdemographicsScalarFieldEnum: {
    CustomerTypeID: 'CustomerTypeID',
    CustomerDesc: 'CustomerDesc'
  };

  export type CustomerdemographicsScalarFieldEnum = (typeof CustomerdemographicsScalarFieldEnum)[keyof typeof CustomerdemographicsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    CustomerID: 'CustomerID',
    CompanyName: 'CompanyName',
    ContactName: 'ContactName',
    ContactTitle: 'ContactTitle',
    Address: 'Address',
    City: 'City',
    Region: 'Region',
    PostalCode: 'PostalCode',
    Country: 'Country',
    Phone: 'Phone',
    Fax: 'Fax'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    EmployeeID: 'EmployeeID',
    LastName: 'LastName',
    FirstName: 'FirstName',
    Title: 'Title',
    TitleOfCourtesy: 'TitleOfCourtesy',
    BirthDate: 'BirthDate',
    HireDate: 'HireDate',
    Address: 'Address',
    City: 'City',
    Region: 'Region',
    PostalCode: 'PostalCode',
    Country: 'Country',
    HomePhone: 'HomePhone',
    Extension: 'Extension',
    Photo: 'Photo',
    Notes: 'Notes',
    ReportsTo: 'ReportsTo',
    PhotoPath: 'PhotoPath'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const EmployeeterritoriesScalarFieldEnum: {
    EmployeeID: 'EmployeeID',
    TerritoryID: 'TerritoryID'
  };

  export type EmployeeterritoriesScalarFieldEnum = (typeof EmployeeterritoriesScalarFieldEnum)[keyof typeof EmployeeterritoriesScalarFieldEnum]


  export const OrderdetailsScalarFieldEnum: {
    OrderID: 'OrderID',
    ProductID: 'ProductID',
    UnitPrice: 'UnitPrice',
    Quantity: 'Quantity',
    Discount: 'Discount'
  };

  export type OrderdetailsScalarFieldEnum = (typeof OrderdetailsScalarFieldEnum)[keyof typeof OrderdetailsScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    OrderID: 'OrderID',
    CustomerID: 'CustomerID',
    EmployeeID: 'EmployeeID',
    OrderDate: 'OrderDate',
    RequiredDate: 'RequiredDate',
    ShippedDate: 'ShippedDate',
    ShipVia: 'ShipVia',
    Freight: 'Freight',
    ShipName: 'ShipName',
    ShipAddress: 'ShipAddress',
    ShipCity: 'ShipCity',
    ShipRegion: 'ShipRegion',
    ShipPostalCode: 'ShipPostalCode',
    ShipCountry: 'ShipCountry'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    ProductID: 'ProductID',
    ProductName: 'ProductName',
    SupplierID: 'SupplierID',
    CategoryID: 'CategoryID',
    QuantityPerUnit: 'QuantityPerUnit',
    UnitPrice: 'UnitPrice',
    UnitsInStock: 'UnitsInStock',
    UnitsOnOrder: 'UnitsOnOrder',
    ReorderLevel: 'ReorderLevel',
    Discontinued: 'Discontinued'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const RegionsScalarFieldEnum: {
    RegionID: 'RegionID',
    RegionDescription: 'RegionDescription'
  };

  export type RegionsScalarFieldEnum = (typeof RegionsScalarFieldEnum)[keyof typeof RegionsScalarFieldEnum]


  export const ShippersScalarFieldEnum: {
    ShipperID: 'ShipperID',
    CompanyName: 'CompanyName',
    Phone: 'Phone'
  };

  export type ShippersScalarFieldEnum = (typeof ShippersScalarFieldEnum)[keyof typeof ShippersScalarFieldEnum]


  export const SuppliersScalarFieldEnum: {
    SupplierID: 'SupplierID',
    CompanyName: 'CompanyName',
    ContactName: 'ContactName',
    ContactTitle: 'ContactTitle',
    Address: 'Address',
    City: 'City',
    Region: 'Region',
    PostalCode: 'PostalCode',
    Country: 'Country',
    Phone: 'Phone',
    Fax: 'Fax',
    HomePage: 'HomePage'
  };

  export type SuppliersScalarFieldEnum = (typeof SuppliersScalarFieldEnum)[keyof typeof SuppliersScalarFieldEnum]


  export const TerritoriesScalarFieldEnum: {
    TerritoryID: 'TerritoryID',
    TerritoryDescription: 'TerritoryDescription',
    RegionID: 'RegionID'
  };

  export type TerritoriesScalarFieldEnum = (typeof TerritoriesScalarFieldEnum)[keyof typeof TerritoriesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type categoriesWhereInput = {
    AND?: Enumerable<categoriesWhereInput>
    OR?: Enumerable<categoriesWhereInput>
    NOT?: Enumerable<categoriesWhereInput>
    CategoryID?: IntFilter | number
    CategoryName?: StringNullableFilter | string | null
    Description?: StringNullableFilter | string | null
    Picture?: BytesNullableFilter | Buffer | null
    products_categoriesToproducts_CategoryID?: ProductsListRelationFilter
  }

  export type categoriesOrderByInput = {
    CategoryID?: SortOrder
    CategoryName?: SortOrder
    Description?: SortOrder
    Picture?: SortOrder
  }

  export type categoriesWhereUniqueInput = {
    CategoryID?: number
  }

  export type customercustomerdemoWhereInput = {
    AND?: Enumerable<customercustomerdemoWhereInput>
    OR?: Enumerable<customercustomerdemoWhereInput>
    NOT?: Enumerable<customercustomerdemoWhereInput>
    CustomerID?: StringFilter | string
    CustomerTypeID?: StringNullableFilter | string | null
    customers?: XOR<CustomersRelationFilter, customersWhereInput>
    customerdemographics?: XOR<CustomerdemographicsRelationFilter, customerdemographicsWhereInput> | null
  }

  export type customercustomerdemoOrderByInput = {
    CustomerID?: SortOrder
    CustomerTypeID?: SortOrder
  }

  export type customercustomerdemoWhereUniqueInput = {
    CustomerID?: string
  }

  export type customerdemographicsWhereInput = {
    AND?: Enumerable<customerdemographicsWhereInput>
    OR?: Enumerable<customerdemographicsWhereInput>
    NOT?: Enumerable<customerdemographicsWhereInput>
    CustomerTypeID?: StringFilter | string
    CustomerDesc?: StringNullableFilter | string | null
    customercustomerdemo?: CustomercustomerdemoListRelationFilter
  }

  export type customerdemographicsOrderByInput = {
    CustomerTypeID?: SortOrder
    CustomerDesc?: SortOrder
  }

  export type customerdemographicsWhereUniqueInput = {
    CustomerTypeID?: string
  }

  export type customersWhereInput = {
    AND?: Enumerable<customersWhereInput>
    OR?: Enumerable<customersWhereInput>
    NOT?: Enumerable<customersWhereInput>
    CustomerID?: StringFilter | string
    CompanyName?: StringFilter | string
    ContactName?: StringFilter | string
    ContactTitle?: StringFilter | string
    Address?: StringFilter | string
    City?: StringFilter | string
    Region?: StringFilter | string
    PostalCode?: StringFilter | string
    Country?: StringFilter | string
    Phone?: StringFilter | string
    Fax?: StringFilter | string
    customercustomerdemo?: XOR<CustomercustomerdemoRelationFilter, customercustomerdemoWhereInput> | null
    orders?: OrdersListRelationFilter
  }

  export type customersOrderByInput = {
    CustomerID?: SortOrder
    CompanyName?: SortOrder
    ContactName?: SortOrder
    ContactTitle?: SortOrder
    Address?: SortOrder
    City?: SortOrder
    Region?: SortOrder
    PostalCode?: SortOrder
    Country?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
  }

  export type customersWhereUniqueInput = {
    CustomerID?: string
  }

  export type employeesWhereInput = {
    AND?: Enumerable<employeesWhereInput>
    OR?: Enumerable<employeesWhereInput>
    NOT?: Enumerable<employeesWhereInput>
    EmployeeID?: IntFilter | number
    LastName?: StringNullableFilter | string | null
    FirstName?: StringNullableFilter | string | null
    Title?: StringNullableFilter | string | null
    TitleOfCourtesy?: StringNullableFilter | string | null
    BirthDate?: DateTimeNullableFilter | Date | string | null
    HireDate?: DateTimeNullableFilter | Date | string | null
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    Region?: StringNullableFilter | string | null
    PostalCode?: StringNullableFilter | string | null
    Country?: StringNullableFilter | string | null
    HomePhone?: StringNullableFilter | string | null
    Extension?: StringNullableFilter | string | null
    Photo?: BytesNullableFilter | Buffer | null
    Notes?: StringNullableFilter | string | null
    ReportsTo?: IntNullableFilter | number | null
    PhotoPath?: StringNullableFilter | string | null
    employeeterritories?: XOR<EmployeeterritoriesRelationFilter, employeeterritoriesWhereInput> | null
    orders?: OrdersListRelationFilter
  }

  export type employeesOrderByInput = {
    EmployeeID?: SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    Title?: SortOrder
    TitleOfCourtesy?: SortOrder
    BirthDate?: SortOrder
    HireDate?: SortOrder
    Address?: SortOrder
    City?: SortOrder
    Region?: SortOrder
    PostalCode?: SortOrder
    Country?: SortOrder
    HomePhone?: SortOrder
    Extension?: SortOrder
    Photo?: SortOrder
    Notes?: SortOrder
    ReportsTo?: SortOrder
    PhotoPath?: SortOrder
  }

  export type employeesWhereUniqueInput = {
    EmployeeID?: number
  }

  export type employeeterritoriesWhereInput = {
    AND?: Enumerable<employeeterritoriesWhereInput>
    OR?: Enumerable<employeeterritoriesWhereInput>
    NOT?: Enumerable<employeeterritoriesWhereInput>
    EmployeeID?: IntFilter | number
    TerritoryID?: StringNullableFilter | string | null
    employees?: XOR<EmployeesRelationFilter, employeesWhereInput>
    territories?: XOR<TerritoriesRelationFilter, territoriesWhereInput> | null
  }

  export type employeeterritoriesOrderByInput = {
    EmployeeID?: SortOrder
    TerritoryID?: SortOrder
  }

  export type employeeterritoriesWhereUniqueInput = {
    EmployeeID?: number
  }

  export type orderdetailsWhereInput = {
    AND?: Enumerable<orderdetailsWhereInput>
    OR?: Enumerable<orderdetailsWhereInput>
    NOT?: Enumerable<orderdetailsWhereInput>
    OrderID?: IntFilter | number
    ProductID?: IntNullableFilter | number | null
    UnitPrice?: DecimalNullableFilter | Decimal | number | string | null
    Quantity?: IntNullableFilter | number | null
    Discount?: FloatNullableFilter | number | null
    orders?: XOR<OrdersRelationFilter, ordersWhereInput>
    products?: XOR<ProductsRelationFilter, productsWhereInput> | null
  }

  export type orderdetailsOrderByInput = {
    OrderID?: SortOrder
    ProductID?: SortOrder
    UnitPrice?: SortOrder
    Quantity?: SortOrder
    Discount?: SortOrder
  }

  export type orderdetailsWhereUniqueInput = {
    OrderID?: number
  }

  export type ordersWhereInput = {
    AND?: Enumerable<ordersWhereInput>
    OR?: Enumerable<ordersWhereInput>
    NOT?: Enumerable<ordersWhereInput>
    OrderID?: IntFilter | number
    CustomerID?: StringFilter | string
    EmployeeID?: IntNullableFilter | number | null
    OrderDate?: DateTimeNullableFilter | Date | string | null
    RequiredDate?: DateTimeNullableFilter | Date | string | null
    ShippedDate?: DateTimeNullableFilter | Date | string | null
    ShipVia?: IntNullableFilter | number | null
    Freight?: DecimalNullableFilter | Decimal | number | string | null
    ShipName?: StringNullableFilter | string | null
    ShipAddress?: StringNullableFilter | string | null
    ShipCity?: StringNullableFilter | string | null
    ShipRegion?: StringNullableFilter | string | null
    ShipPostalCode?: StringNullableFilter | string | null
    ShipCountry?: StringNullableFilter | string | null
    customers?: XOR<CustomersRelationFilter, customersWhereInput>
    employees?: XOR<EmployeesRelationFilter, employeesWhereInput> | null
    shippers?: XOR<ShippersRelationFilter, shippersWhereInput> | null
    orderdetails?: XOR<OrderdetailsRelationFilter, orderdetailsWhereInput> | null
  }

  export type ordersOrderByInput = {
    OrderID?: SortOrder
    CustomerID?: SortOrder
    EmployeeID?: SortOrder
    OrderDate?: SortOrder
    RequiredDate?: SortOrder
    ShippedDate?: SortOrder
    ShipVia?: SortOrder
    Freight?: SortOrder
    ShipName?: SortOrder
    ShipAddress?: SortOrder
    ShipCity?: SortOrder
    ShipRegion?: SortOrder
    ShipPostalCode?: SortOrder
    ShipCountry?: SortOrder
  }

  export type ordersWhereUniqueInput = {
    OrderID?: number
  }

  export type productsWhereInput = {
    AND?: Enumerable<productsWhereInput>
    OR?: Enumerable<productsWhereInput>
    NOT?: Enumerable<productsWhereInput>
    ProductID?: IntFilter | number
    ProductName?: StringNullableFilter | string | null
    SupplierID?: IntNullableFilter | number | null
    CategoryID?: IntNullableFilter | number | null
    QuantityPerUnit?: StringNullableFilter | string | null
    UnitPrice?: DecimalNullableFilter | Decimal | number | string | null
    UnitsInStock?: IntNullableFilter | number | null
    UnitsOnOrder?: IntNullableFilter | number | null
    ReorderLevel?: IntNullableFilter | number | null
    Discontinued?: StringNullableFilter | string | null
    category?: XOR<CategoriesRelationFilter, categoriesWhereInput> | null
    supplier?: XOR<SuppliersRelationFilter, suppliersWhereInput> | null
    orderdetails?: OrderdetailsListRelationFilter
  }

  export type productsOrderByInput = {
    ProductID?: SortOrder
    ProductName?: SortOrder
    SupplierID?: SortOrder
    CategoryID?: SortOrder
    QuantityPerUnit?: SortOrder
    UnitPrice?: SortOrder
    UnitsInStock?: SortOrder
    UnitsOnOrder?: SortOrder
    ReorderLevel?: SortOrder
    Discontinued?: SortOrder
  }

  export type productsWhereUniqueInput = {
    ProductID?: number
  }

  export type regionsWhereInput = {
    AND?: Enumerable<regionsWhereInput>
    OR?: Enumerable<regionsWhereInput>
    NOT?: Enumerable<regionsWhereInput>
    RegionID?: IntFilter | number
    RegionDescription?: StringNullableFilter | string | null
    territories?: TerritoriesListRelationFilter
  }

  export type regionsOrderByInput = {
    RegionID?: SortOrder
    RegionDescription?: SortOrder
  }

  export type regionsWhereUniqueInput = {
    RegionID?: number
  }

  export type shippersWhereInput = {
    AND?: Enumerable<shippersWhereInput>
    OR?: Enumerable<shippersWhereInput>
    NOT?: Enumerable<shippersWhereInput>
    ShipperID?: IntFilter | number
    CompanyName?: StringNullableFilter | string | null
    Phone?: StringNullableFilter | string | null
    orders?: OrdersListRelationFilter
  }

  export type shippersOrderByInput = {
    ShipperID?: SortOrder
    CompanyName?: SortOrder
    Phone?: SortOrder
  }

  export type shippersWhereUniqueInput = {
    ShipperID?: number
  }

  export type suppliersWhereInput = {
    AND?: Enumerable<suppliersWhereInput>
    OR?: Enumerable<suppliersWhereInput>
    NOT?: Enumerable<suppliersWhereInput>
    SupplierID?: IntFilter | number
    CompanyName?: StringNullableFilter | string | null
    ContactName?: StringNullableFilter | string | null
    ContactTitle?: StringNullableFilter | string | null
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    Region?: StringNullableFilter | string | null
    PostalCode?: StringNullableFilter | string | null
    Country?: StringNullableFilter | string | null
    Phone?: StringNullableFilter | string | null
    Fax?: StringNullableFilter | string | null
    HomePage?: StringNullableFilter | string | null
    products?: ProductsListRelationFilter
  }

  export type suppliersOrderByInput = {
    SupplierID?: SortOrder
    CompanyName?: SortOrder
    ContactName?: SortOrder
    ContactTitle?: SortOrder
    Address?: SortOrder
    City?: SortOrder
    Region?: SortOrder
    PostalCode?: SortOrder
    Country?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    HomePage?: SortOrder
  }

  export type suppliersWhereUniqueInput = {
    SupplierID?: number
  }

  export type territoriesWhereInput = {
    AND?: Enumerable<territoriesWhereInput>
    OR?: Enumerable<territoriesWhereInput>
    NOT?: Enumerable<territoriesWhereInput>
    TerritoryID?: StringFilter | string
    TerritoryDescription?: StringNullableFilter | string | null
    RegionID?: IntNullableFilter | number | null
    regions?: XOR<RegionsRelationFilter, regionsWhereInput> | null
    employeeterritories?: EmployeeterritoriesListRelationFilter
  }

  export type territoriesOrderByInput = {
    TerritoryID?: SortOrder
    TerritoryDescription?: SortOrder
    RegionID?: SortOrder
  }

  export type territoriesWhereUniqueInput = {
    TerritoryID?: string
  }

  export type categoriesCreateInput = {
    CategoryID: number
    CategoryName?: string | null
    Description?: string | null
    Picture?: Buffer | null
    products_categoriesToproducts_CategoryID?: productsCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUncheckedCreateInput = {
    CategoryID: number
    CategoryName?: string | null
    Description?: string | null
    Picture?: Buffer | null
    products_categoriesToproducts_CategoryID?: productsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUpdateInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    products_categoriesToproducts_CategoryID?: productsUpdateManyWithoutCategoryInput
  }

  export type categoriesUncheckedUpdateInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    products_categoriesToproducts_CategoryID?: productsUncheckedUpdateManyWithoutCategoryInput
  }

  export type categoriesUpdateManyMutationInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type customercustomerdemoCreateInput = {
    customers: customersCreateNestedOneWithoutCustomercustomerdemoInput
    customerdemographics?: customerdemographicsCreateNestedOneWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedCreateInput = {
    CustomerID: string
    CustomerTypeID?: string | null
  }

  export type customercustomerdemoUpdateInput = {
    customers?: customersUpdateOneRequiredWithoutCustomercustomerdemoInput
    customerdemographics?: customerdemographicsUpdateOneWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedUpdateInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CustomerTypeID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customercustomerdemoUpdateManyMutationInput = {

  }

  export type customercustomerdemoUncheckedUpdateManyInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CustomerTypeID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerdemographicsCreateInput = {
    CustomerTypeID: string
    CustomerDesc?: string | null
    customercustomerdemo?: customercustomerdemoCreateNestedManyWithoutCustomerdemographicsInput
  }

  export type customerdemographicsUncheckedCreateInput = {
    CustomerTypeID: string
    CustomerDesc?: string | null
    customercustomerdemo?: customercustomerdemoUncheckedCreateNestedManyWithoutCustomerdemographicsInput
  }

  export type customerdemographicsUpdateInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customercustomerdemo?: customercustomerdemoUpdateManyWithoutCustomerdemographicsInput
  }

  export type customerdemographicsUncheckedUpdateInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customercustomerdemo?: customercustomerdemoUncheckedUpdateManyWithoutCustomerdemographicsInput
  }

  export type customerdemographicsUpdateManyMutationInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerdemographicsUncheckedUpdateManyInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersCreateInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    customercustomerdemo?: customercustomerdemoCreateNestedOneWithoutCustomersInput
    orders?: ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    customercustomerdemo?: customercustomerdemoUncheckedCreateNestedOneWithoutCustomersInput
    orders?: ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersUpdateInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    customercustomerdemo?: customercustomerdemoUpdateOneWithoutCustomersInput
    orders?: ordersUpdateManyWithoutCustomersInput
  }

  export type customersUncheckedUpdateInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    customercustomerdemo?: customercustomerdemoUncheckedUpdateOneWithoutCustomersInput
    orders?: ordersUncheckedUpdateManyWithoutCustomersInput
  }

  export type customersUpdateManyMutationInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
  }

  export type customersUncheckedUpdateManyInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
  }

  export type employeesCreateInput = {
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    employeeterritories?: employeeterritoriesCreateNestedOneWithoutEmployeesInput
    orders?: ordersCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateInput = {
    EmployeeID?: number
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    employeeterritories?: employeeterritoriesUncheckedCreateNestedOneWithoutEmployeesInput
    orders?: ordersUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUpdateInput = {
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUpdateOneWithoutEmployeesInput
    orders?: ordersUpdateManyWithoutEmployeesInput
  }

  export type employeesUncheckedUpdateInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUncheckedUpdateOneWithoutEmployeesInput
    orders?: ordersUncheckedUpdateManyWithoutEmployeesInput
  }

  export type employeesUpdateManyMutationInput = {
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeesUncheckedUpdateManyInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeterritoriesCreateInput = {
    employees: employeesCreateNestedOneWithoutEmployeeterritoriesInput
    territories?: territoriesCreateNestedOneWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedCreateInput = {
    EmployeeID: number
    TerritoryID?: string | null
  }

  export type employeeterritoriesUpdateInput = {
    employees?: employeesUpdateOneRequiredWithoutEmployeeterritoriesInput
    territories?: territoriesUpdateOneWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedUpdateInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    TerritoryID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeterritoriesUpdateManyMutationInput = {

  }

  export type employeeterritoriesUncheckedUpdateManyInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    TerritoryID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderdetailsCreateInput = {
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
    orders: ordersCreateNestedOneWithoutOrderdetailsInput
    products?: productsCreateNestedOneWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedCreateInput = {
    OrderID: number
    ProductID?: number | null
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
  }

  export type orderdetailsUpdateInput = {
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: ordersUpdateOneRequiredWithoutOrderdetailsInput
    products?: productsUpdateOneWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedUpdateInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    ProductID?: NullableIntFieldUpdateOperationsInput | number | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type orderdetailsUpdateManyMutationInput = {
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type orderdetailsUncheckedUpdateManyInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    ProductID?: NullableIntFieldUpdateOperationsInput | number | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ordersCreateInput = {
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    customers: customersCreateNestedOneWithoutOrdersInput
    employees?: employeesCreateNestedOneWithoutOrdersInput
    shippers?: shippersCreateNestedOneWithoutOrdersInput
    orderdetails?: orderdetailsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateInput = {
    OrderID?: number
    CustomerID: string
    EmployeeID?: number | null
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    ShipVia?: number | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersUpdateInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: customersUpdateOneRequiredWithoutOrdersInput
    employees?: employeesUpdateOneWithoutOrdersInput
    shippers?: shippersUpdateOneWithoutOrdersInput
    orderdetails?: orderdetailsUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    CustomerID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateOneWithoutOrdersInput
  }

  export type ordersUpdateManyMutationInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUncheckedUpdateManyInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    CustomerID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsCreateInput = {
    ProductName?: string | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    category?: categoriesCreateNestedOneWithoutProducts_categoriesToproducts_CategoryIDInput
    supplier?: suppliersCreateNestedOneWithoutProductsInput
    orderdetails?: orderdetailsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateInput = {
    ProductID?: number
    ProductName?: string | null
    SupplierID?: number | null
    CategoryID?: number | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsUpdateInput = {
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    category?: categoriesUpdateOneWithoutProducts_categoriesToproducts_CategoryIDInput
    supplier?: suppliersUpdateOneWithoutProductsInput
    orderdetails?: orderdetailsUpdateManyWithoutProductsInput
  }

  export type productsUncheckedUpdateInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    SupplierID?: NullableIntFieldUpdateOperationsInput | number | null
    CategoryID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateManyWithoutProductsInput
  }

  export type productsUpdateManyMutationInput = {
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsUncheckedUpdateManyInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    SupplierID?: NullableIntFieldUpdateOperationsInput | number | null
    CategoryID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type regionsCreateInput = {
    RegionID: number
    RegionDescription?: string | null
    territories?: territoriesCreateNestedManyWithoutRegionsInput
  }

  export type regionsUncheckedCreateInput = {
    RegionID: number
    RegionDescription?: string | null
    territories?: territoriesUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type regionsUpdateInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    territories?: territoriesUpdateManyWithoutRegionsInput
  }

  export type regionsUncheckedUpdateInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    territories?: territoriesUncheckedUpdateManyWithoutRegionsInput
  }

  export type regionsUpdateManyMutationInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type regionsUncheckedUpdateManyInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shippersCreateInput = {
    CompanyName?: string | null
    Phone?: string | null
    orders?: ordersCreateNestedManyWithoutShippersInput
  }

  export type shippersUncheckedCreateInput = {
    ShipperID?: number
    CompanyName?: string | null
    Phone?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutShippersInput
  }

  export type shippersUpdateInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutShippersInput
  }

  export type shippersUncheckedUpdateInput = {
    ShipperID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutShippersInput
  }

  export type shippersUpdateManyMutationInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shippersUncheckedUpdateManyInput = {
    ShipperID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type suppliersCreateInput = {
    CompanyName?: string | null
    ContactName?: string | null
    ContactTitle?: string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    Phone?: string | null
    Fax?: string | null
    HomePage?: string | null
    products?: productsCreateNestedManyWithoutSupplierInput
  }

  export type suppliersUncheckedCreateInput = {
    SupplierID?: number
    CompanyName?: string | null
    ContactName?: string | null
    ContactTitle?: string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    Phone?: string | null
    Fax?: string | null
    HomePage?: string | null
    products?: productsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type suppliersUpdateInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
    products?: productsUpdateManyWithoutSupplierInput
  }

  export type suppliersUncheckedUpdateInput = {
    SupplierID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
    products?: productsUncheckedUpdateManyWithoutSupplierInput
  }

  export type suppliersUpdateManyMutationInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type suppliersUncheckedUpdateManyInput = {
    SupplierID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type territoriesCreateInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    regions?: regionsCreateNestedOneWithoutTerritoriesInput
    employeeterritories?: employeeterritoriesCreateNestedManyWithoutTerritoriesInput
  }

  export type territoriesUncheckedCreateInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    RegionID?: number | null
    employeeterritories?: employeeterritoriesUncheckedCreateNestedManyWithoutTerritoriesInput
  }

  export type territoriesUpdateInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: regionsUpdateOneWithoutTerritoriesInput
    employeeterritories?: employeeterritoriesUpdateManyWithoutTerritoriesInput
  }

  export type territoriesUncheckedUpdateInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    RegionID?: NullableIntFieldUpdateOperationsInput | number | null
    employeeterritories?: employeeterritoriesUncheckedUpdateManyWithoutTerritoriesInput
  }

  export type territoriesUpdateManyMutationInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type territoriesUncheckedUpdateManyInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    RegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type CustomersRelationFilter = {
    is?: customersWhereInput
    isNot?: customersWhereInput
  }

  export type CustomerdemographicsRelationFilter = {
    is?: customerdemographicsWhereInput | null
    isNot?: customerdemographicsWhereInput | null
  }

  export type CustomercustomerdemoListRelationFilter = {
    every?: customercustomerdemoWhereInput
    some?: customercustomerdemoWhereInput
    none?: customercustomerdemoWhereInput
  }

  export type CustomercustomerdemoRelationFilter = {
    is?: customercustomerdemoWhereInput | null
    isNot?: customercustomerdemoWhereInput | null
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EmployeeterritoriesRelationFilter = {
    is?: employeeterritoriesWhereInput | null
    isNot?: employeeterritoriesWhereInput | null
  }

  export type EmployeesRelationFilter = {
    is?: employeesWhereInput
    isNot?: employeesWhereInput
  }

  export type TerritoriesRelationFilter = {
    is?: territoriesWhereInput | null
    isNot?: territoriesWhereInput | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type OrdersRelationFilter = {
    is?: ordersWhereInput
    isNot?: ordersWhereInput
  }

  export type ProductsRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type ShippersRelationFilter = {
    is?: shippersWhereInput | null
    isNot?: shippersWhereInput | null
  }

  export type OrderdetailsRelationFilter = {
    is?: orderdetailsWhereInput | null
    isNot?: orderdetailsWhereInput | null
  }

  export type CategoriesRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type SuppliersRelationFilter = {
    is?: suppliersWhereInput | null
    isNot?: suppliersWhereInput | null
  }

  export type OrderdetailsListRelationFilter = {
    every?: orderdetailsWhereInput
    some?: orderdetailsWhereInput
    none?: orderdetailsWhereInput
  }

  export type TerritoriesListRelationFilter = {
    every?: territoriesWhereInput
    some?: territoriesWhereInput
    none?: territoriesWhereInput
  }

  export type RegionsRelationFilter = {
    is?: regionsWhereInput | null
    isNot?: regionsWhereInput | null
  }

  export type EmployeeterritoriesListRelationFilter = {
    every?: employeeterritoriesWhereInput
    some?: employeeterritoriesWhereInput
    none?: employeeterritoriesWhereInput
  }

  export type productsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<productsCreateWithoutCategoryInput>, Enumerable<productsUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutCategoryInput>
    connect?: Enumerable<productsWhereUniqueInput>
  }

  export type productsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<productsCreateWithoutCategoryInput>, Enumerable<productsUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutCategoryInput>
    connect?: Enumerable<productsWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type productsUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<productsCreateWithoutCategoryInput>, Enumerable<productsUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutCategoryInput>
    connect?: Enumerable<productsWhereUniqueInput>
    set?: Enumerable<productsWhereUniqueInput>
    disconnect?: Enumerable<productsWhereUniqueInput>
    delete?: Enumerable<productsWhereUniqueInput>
    update?: Enumerable<productsUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<productsUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<productsScalarWhereInput>
  }

  export type productsUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<productsCreateWithoutCategoryInput>, Enumerable<productsUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutCategoryInput>
    connect?: Enumerable<productsWhereUniqueInput>
    set?: Enumerable<productsWhereUniqueInput>
    disconnect?: Enumerable<productsWhereUniqueInput>
    delete?: Enumerable<productsWhereUniqueInput>
    update?: Enumerable<productsUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<productsUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<productsScalarWhereInput>
  }

  export type customersCreateNestedOneWithoutCustomercustomerdemoInput = {
    create?: XOR<customersCreateWithoutCustomercustomerdemoInput, customersUncheckedCreateWithoutCustomercustomerdemoInput>
    connectOrCreate?: customersCreateOrConnectWithoutCustomercustomerdemoInput
    connect?: customersWhereUniqueInput
  }

  export type customerdemographicsCreateNestedOneWithoutCustomercustomerdemoInput = {
    create?: XOR<customerdemographicsCreateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedCreateWithoutCustomercustomerdemoInput>
    connectOrCreate?: customerdemographicsCreateOrConnectWithoutCustomercustomerdemoInput
    connect?: customerdemographicsWhereUniqueInput
  }

  export type customersUpdateOneRequiredWithoutCustomercustomerdemoInput = {
    create?: XOR<customersCreateWithoutCustomercustomerdemoInput, customersUncheckedCreateWithoutCustomercustomerdemoInput>
    connectOrCreate?: customersCreateOrConnectWithoutCustomercustomerdemoInput
    upsert?: customersUpsertWithoutCustomercustomerdemoInput
    connect?: customersWhereUniqueInput
    update?: XOR<customersUpdateWithoutCustomercustomerdemoInput, customersUncheckedUpdateWithoutCustomercustomerdemoInput>
  }

  export type customerdemographicsUpdateOneWithoutCustomercustomerdemoInput = {
    create?: XOR<customerdemographicsCreateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedCreateWithoutCustomercustomerdemoInput>
    connectOrCreate?: customerdemographicsCreateOrConnectWithoutCustomercustomerdemoInput
    upsert?: customerdemographicsUpsertWithoutCustomercustomerdemoInput
    connect?: customerdemographicsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<customerdemographicsUpdateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedUpdateWithoutCustomercustomerdemoInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type customercustomerdemoCreateNestedManyWithoutCustomerdemographicsInput = {
    create?: XOR<Enumerable<customercustomerdemoCreateWithoutCustomerdemographicsInput>, Enumerable<customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>>
    connectOrCreate?: Enumerable<customercustomerdemoCreateOrConnectWithoutCustomerdemographicsInput>
    connect?: Enumerable<customercustomerdemoWhereUniqueInput>
  }

  export type customercustomerdemoUncheckedCreateNestedManyWithoutCustomerdemographicsInput = {
    create?: XOR<Enumerable<customercustomerdemoCreateWithoutCustomerdemographicsInput>, Enumerable<customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>>
    connectOrCreate?: Enumerable<customercustomerdemoCreateOrConnectWithoutCustomerdemographicsInput>
    connect?: Enumerable<customercustomerdemoWhereUniqueInput>
  }

  export type customercustomerdemoUpdateManyWithoutCustomerdemographicsInput = {
    create?: XOR<Enumerable<customercustomerdemoCreateWithoutCustomerdemographicsInput>, Enumerable<customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>>
    connectOrCreate?: Enumerable<customercustomerdemoCreateOrConnectWithoutCustomerdemographicsInput>
    upsert?: Enumerable<customercustomerdemoUpsertWithWhereUniqueWithoutCustomerdemographicsInput>
    connect?: Enumerable<customercustomerdemoWhereUniqueInput>
    set?: Enumerable<customercustomerdemoWhereUniqueInput>
    disconnect?: Enumerable<customercustomerdemoWhereUniqueInput>
    delete?: Enumerable<customercustomerdemoWhereUniqueInput>
    update?: Enumerable<customercustomerdemoUpdateWithWhereUniqueWithoutCustomerdemographicsInput>
    updateMany?: Enumerable<customercustomerdemoUpdateManyWithWhereWithoutCustomerdemographicsInput>
    deleteMany?: Enumerable<customercustomerdemoScalarWhereInput>
  }

  export type customercustomerdemoUncheckedUpdateManyWithoutCustomerdemographicsInput = {
    create?: XOR<Enumerable<customercustomerdemoCreateWithoutCustomerdemographicsInput>, Enumerable<customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>>
    connectOrCreate?: Enumerable<customercustomerdemoCreateOrConnectWithoutCustomerdemographicsInput>
    upsert?: Enumerable<customercustomerdemoUpsertWithWhereUniqueWithoutCustomerdemographicsInput>
    connect?: Enumerable<customercustomerdemoWhereUniqueInput>
    set?: Enumerable<customercustomerdemoWhereUniqueInput>
    disconnect?: Enumerable<customercustomerdemoWhereUniqueInput>
    delete?: Enumerable<customercustomerdemoWhereUniqueInput>
    update?: Enumerable<customercustomerdemoUpdateWithWhereUniqueWithoutCustomerdemographicsInput>
    updateMany?: Enumerable<customercustomerdemoUpdateManyWithWhereWithoutCustomerdemographicsInput>
    deleteMany?: Enumerable<customercustomerdemoScalarWhereInput>
  }

  export type customercustomerdemoCreateNestedOneWithoutCustomersInput = {
    create?: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customercustomerdemoCreateOrConnectWithoutCustomersInput
    connect?: customercustomerdemoWhereUniqueInput
  }

  export type ordersCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutCustomersInput>, Enumerable<ordersUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutCustomersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type customercustomerdemoUncheckedCreateNestedOneWithoutCustomersInput = {
    create?: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customercustomerdemoCreateOrConnectWithoutCustomersInput
    connect?: customercustomerdemoWhereUniqueInput
  }

  export type ordersUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutCustomersInput>, Enumerable<ordersUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutCustomersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type customercustomerdemoUpdateOneWithoutCustomersInput = {
    create?: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customercustomerdemoCreateOrConnectWithoutCustomersInput
    upsert?: customercustomerdemoUpsertWithoutCustomersInput
    connect?: customercustomerdemoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<customercustomerdemoUpdateWithoutCustomersInput, customercustomerdemoUncheckedUpdateWithoutCustomersInput>
  }

  export type ordersUpdateManyWithoutCustomersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutCustomersInput>, Enumerable<ordersUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutCustomersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type customercustomerdemoUncheckedUpdateOneWithoutCustomersInput = {
    create?: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: customercustomerdemoCreateOrConnectWithoutCustomersInput
    upsert?: customercustomerdemoUpsertWithoutCustomersInput
    connect?: customercustomerdemoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<customercustomerdemoUpdateWithoutCustomersInput, customercustomerdemoUncheckedUpdateWithoutCustomersInput>
  }

  export type ordersUncheckedUpdateManyWithoutCustomersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutCustomersInput>, Enumerable<ordersUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutCustomersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type employeeterritoriesCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: employeeterritoriesCreateOrConnectWithoutEmployeesInput
    connect?: employeeterritoriesWhereUniqueInput
  }

  export type ordersCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutEmployeesInput>, Enumerable<ordersUncheckedCreateWithoutEmployeesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutEmployeesInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type employeeterritoriesUncheckedCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: employeeterritoriesCreateOrConnectWithoutEmployeesInput
    connect?: employeeterritoriesWhereUniqueInput
  }

  export type ordersUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutEmployeesInput>, Enumerable<ordersUncheckedCreateWithoutEmployeesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutEmployeesInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type employeeterritoriesUpdateOneWithoutEmployeesInput = {
    create?: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: employeeterritoriesCreateOrConnectWithoutEmployeesInput
    upsert?: employeeterritoriesUpsertWithoutEmployeesInput
    connect?: employeeterritoriesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<employeeterritoriesUpdateWithoutEmployeesInput, employeeterritoriesUncheckedUpdateWithoutEmployeesInput>
  }

  export type ordersUpdateManyWithoutEmployeesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutEmployeesInput>, Enumerable<ordersUncheckedCreateWithoutEmployeesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutEmployeesInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutEmployeesInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutEmployeesInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutEmployeesInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type employeeterritoriesUncheckedUpdateOneWithoutEmployeesInput = {
    create?: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: employeeterritoriesCreateOrConnectWithoutEmployeesInput
    upsert?: employeeterritoriesUpsertWithoutEmployeesInput
    connect?: employeeterritoriesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<employeeterritoriesUpdateWithoutEmployeesInput, employeeterritoriesUncheckedUpdateWithoutEmployeesInput>
  }

  export type ordersUncheckedUpdateManyWithoutEmployeesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutEmployeesInput>, Enumerable<ordersUncheckedCreateWithoutEmployeesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutEmployeesInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutEmployeesInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutEmployeesInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutEmployeesInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type employeesCreateNestedOneWithoutEmployeeterritoriesInput = {
    create?: XOR<employeesCreateWithoutEmployeeterritoriesInput, employeesUncheckedCreateWithoutEmployeeterritoriesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutEmployeeterritoriesInput
    connect?: employeesWhereUniqueInput
  }

  export type territoriesCreateNestedOneWithoutEmployeeterritoriesInput = {
    create?: XOR<territoriesCreateWithoutEmployeeterritoriesInput, territoriesUncheckedCreateWithoutEmployeeterritoriesInput>
    connectOrCreate?: territoriesCreateOrConnectWithoutEmployeeterritoriesInput
    connect?: territoriesWhereUniqueInput
  }

  export type employeesUpdateOneRequiredWithoutEmployeeterritoriesInput = {
    create?: XOR<employeesCreateWithoutEmployeeterritoriesInput, employeesUncheckedCreateWithoutEmployeeterritoriesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutEmployeeterritoriesInput
    upsert?: employeesUpsertWithoutEmployeeterritoriesInput
    connect?: employeesWhereUniqueInput
    update?: XOR<employeesUpdateWithoutEmployeeterritoriesInput, employeesUncheckedUpdateWithoutEmployeeterritoriesInput>
  }

  export type territoriesUpdateOneWithoutEmployeeterritoriesInput = {
    create?: XOR<territoriesCreateWithoutEmployeeterritoriesInput, territoriesUncheckedCreateWithoutEmployeeterritoriesInput>
    connectOrCreate?: territoriesCreateOrConnectWithoutEmployeeterritoriesInput
    upsert?: territoriesUpsertWithoutEmployeeterritoriesInput
    connect?: territoriesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<territoriesUpdateWithoutEmployeeterritoriesInput, territoriesUncheckedUpdateWithoutEmployeeterritoriesInput>
  }

  export type ordersCreateNestedOneWithoutOrderdetailsInput = {
    create?: XOR<ordersCreateWithoutOrderdetailsInput, ordersUncheckedCreateWithoutOrderdetailsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrderdetailsInput
    connect?: ordersWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutOrderdetailsInput = {
    create?: XOR<productsCreateWithoutOrderdetailsInput, productsUncheckedCreateWithoutOrderdetailsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrderdetailsInput
    connect?: productsWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ordersUpdateOneRequiredWithoutOrderdetailsInput = {
    create?: XOR<ordersCreateWithoutOrderdetailsInput, ordersUncheckedCreateWithoutOrderdetailsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrderdetailsInput
    upsert?: ordersUpsertWithoutOrderdetailsInput
    connect?: ordersWhereUniqueInput
    update?: XOR<ordersUpdateWithoutOrderdetailsInput, ordersUncheckedUpdateWithoutOrderdetailsInput>
  }

  export type productsUpdateOneWithoutOrderdetailsInput = {
    create?: XOR<productsCreateWithoutOrderdetailsInput, productsUncheckedCreateWithoutOrderdetailsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrderdetailsInput
    upsert?: productsUpsertWithoutOrderdetailsInput
    connect?: productsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<productsUpdateWithoutOrderdetailsInput, productsUncheckedUpdateWithoutOrderdetailsInput>
  }

  export type customersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    connect?: customersWhereUniqueInput
  }

  export type employeesCreateNestedOneWithoutOrdersInput = {
    create?: XOR<employeesCreateWithoutOrdersInput, employeesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: employeesCreateOrConnectWithoutOrdersInput
    connect?: employeesWhereUniqueInput
  }

  export type shippersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<shippersCreateWithoutOrdersInput, shippersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: shippersCreateOrConnectWithoutOrdersInput
    connect?: shippersWhereUniqueInput
  }

  export type orderdetailsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: orderdetailsCreateOrConnectWithoutOrdersInput
    connect?: orderdetailsWhereUniqueInput
  }

  export type orderdetailsUncheckedCreateNestedOneWithoutOrdersInput = {
    create?: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: orderdetailsCreateOrConnectWithoutOrdersInput
    connect?: orderdetailsWhereUniqueInput
  }

  export type customersUpdateOneRequiredWithoutOrdersInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    upsert?: customersUpsertWithoutOrdersInput
    connect?: customersWhereUniqueInput
    update?: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
  }

  export type employeesUpdateOneWithoutOrdersInput = {
    create?: XOR<employeesCreateWithoutOrdersInput, employeesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: employeesCreateOrConnectWithoutOrdersInput
    upsert?: employeesUpsertWithoutOrdersInput
    connect?: employeesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<employeesUpdateWithoutOrdersInput, employeesUncheckedUpdateWithoutOrdersInput>
  }

  export type shippersUpdateOneWithoutOrdersInput = {
    create?: XOR<shippersCreateWithoutOrdersInput, shippersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: shippersCreateOrConnectWithoutOrdersInput
    upsert?: shippersUpsertWithoutOrdersInput
    connect?: shippersWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<shippersUpdateWithoutOrdersInput, shippersUncheckedUpdateWithoutOrdersInput>
  }

  export type orderdetailsUpdateOneWithoutOrdersInput = {
    create?: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: orderdetailsCreateOrConnectWithoutOrdersInput
    upsert?: orderdetailsUpsertWithoutOrdersInput
    connect?: orderdetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<orderdetailsUpdateWithoutOrdersInput, orderdetailsUncheckedUpdateWithoutOrdersInput>
  }

  export type orderdetailsUncheckedUpdateOneWithoutOrdersInput = {
    create?: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: orderdetailsCreateOrConnectWithoutOrdersInput
    upsert?: orderdetailsUpsertWithoutOrdersInput
    connect?: orderdetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<orderdetailsUpdateWithoutOrdersInput, orderdetailsUncheckedUpdateWithoutOrdersInput>
  }

  export type categoriesCreateNestedOneWithoutProducts_categoriesToproducts_CategoryIDInput = {
    create?: XOR<categoriesCreateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedCreateWithoutProducts_categoriesToproducts_CategoryIDInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProducts_categoriesToproducts_CategoryIDInput
    connect?: categoriesWhereUniqueInput
  }

  export type suppliersCreateNestedOneWithoutProductsInput = {
    create?: XOR<suppliersCreateWithoutProductsInput, suppliersUncheckedCreateWithoutProductsInput>
    connectOrCreate?: suppliersCreateOrConnectWithoutProductsInput
    connect?: suppliersWhereUniqueInput
  }

  export type orderdetailsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<orderdetailsCreateWithoutProductsInput>, Enumerable<orderdetailsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<orderdetailsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<orderdetailsWhereUniqueInput>
  }

  export type orderdetailsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<orderdetailsCreateWithoutProductsInput>, Enumerable<orderdetailsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<orderdetailsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<orderdetailsWhereUniqueInput>
  }

  export type categoriesUpdateOneWithoutProducts_categoriesToproducts_CategoryIDInput = {
    create?: XOR<categoriesCreateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedCreateWithoutProducts_categoriesToproducts_CategoryIDInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProducts_categoriesToproducts_CategoryIDInput
    upsert?: categoriesUpsertWithoutProducts_categoriesToproducts_CategoryIDInput
    connect?: categoriesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<categoriesUpdateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedUpdateWithoutProducts_categoriesToproducts_CategoryIDInput>
  }

  export type suppliersUpdateOneWithoutProductsInput = {
    create?: XOR<suppliersCreateWithoutProductsInput, suppliersUncheckedCreateWithoutProductsInput>
    connectOrCreate?: suppliersCreateOrConnectWithoutProductsInput
    upsert?: suppliersUpsertWithoutProductsInput
    connect?: suppliersWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<suppliersUpdateWithoutProductsInput, suppliersUncheckedUpdateWithoutProductsInput>
  }

  export type orderdetailsUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<orderdetailsCreateWithoutProductsInput>, Enumerable<orderdetailsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<orderdetailsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<orderdetailsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<orderdetailsWhereUniqueInput>
    set?: Enumerable<orderdetailsWhereUniqueInput>
    disconnect?: Enumerable<orderdetailsWhereUniqueInput>
    delete?: Enumerable<orderdetailsWhereUniqueInput>
    update?: Enumerable<orderdetailsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<orderdetailsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<orderdetailsScalarWhereInput>
  }

  export type orderdetailsUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<orderdetailsCreateWithoutProductsInput>, Enumerable<orderdetailsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<orderdetailsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<orderdetailsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<orderdetailsWhereUniqueInput>
    set?: Enumerable<orderdetailsWhereUniqueInput>
    disconnect?: Enumerable<orderdetailsWhereUniqueInput>
    delete?: Enumerable<orderdetailsWhereUniqueInput>
    update?: Enumerable<orderdetailsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<orderdetailsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<orderdetailsScalarWhereInput>
  }

  export type territoriesCreateNestedManyWithoutRegionsInput = {
    create?: XOR<Enumerable<territoriesCreateWithoutRegionsInput>, Enumerable<territoriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<territoriesCreateOrConnectWithoutRegionsInput>
    connect?: Enumerable<territoriesWhereUniqueInput>
  }

  export type territoriesUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<Enumerable<territoriesCreateWithoutRegionsInput>, Enumerable<territoriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<territoriesCreateOrConnectWithoutRegionsInput>
    connect?: Enumerable<territoriesWhereUniqueInput>
  }

  export type territoriesUpdateManyWithoutRegionsInput = {
    create?: XOR<Enumerable<territoriesCreateWithoutRegionsInput>, Enumerable<territoriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<territoriesCreateOrConnectWithoutRegionsInput>
    upsert?: Enumerable<territoriesUpsertWithWhereUniqueWithoutRegionsInput>
    connect?: Enumerable<territoriesWhereUniqueInput>
    set?: Enumerable<territoriesWhereUniqueInput>
    disconnect?: Enumerable<territoriesWhereUniqueInput>
    delete?: Enumerable<territoriesWhereUniqueInput>
    update?: Enumerable<territoriesUpdateWithWhereUniqueWithoutRegionsInput>
    updateMany?: Enumerable<territoriesUpdateManyWithWhereWithoutRegionsInput>
    deleteMany?: Enumerable<territoriesScalarWhereInput>
  }

  export type territoriesUncheckedUpdateManyWithoutRegionsInput = {
    create?: XOR<Enumerable<territoriesCreateWithoutRegionsInput>, Enumerable<territoriesUncheckedCreateWithoutRegionsInput>>
    connectOrCreate?: Enumerable<territoriesCreateOrConnectWithoutRegionsInput>
    upsert?: Enumerable<territoriesUpsertWithWhereUniqueWithoutRegionsInput>
    connect?: Enumerable<territoriesWhereUniqueInput>
    set?: Enumerable<territoriesWhereUniqueInput>
    disconnect?: Enumerable<territoriesWhereUniqueInput>
    delete?: Enumerable<territoriesWhereUniqueInput>
    update?: Enumerable<territoriesUpdateWithWhereUniqueWithoutRegionsInput>
    updateMany?: Enumerable<territoriesUpdateManyWithWhereWithoutRegionsInput>
    deleteMany?: Enumerable<territoriesScalarWhereInput>
  }

  export type ordersCreateNestedManyWithoutShippersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutShippersInput>, Enumerable<ordersUncheckedCreateWithoutShippersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutShippersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type ordersUncheckedCreateNestedManyWithoutShippersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutShippersInput>, Enumerable<ordersUncheckedCreateWithoutShippersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutShippersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type ordersUpdateManyWithoutShippersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutShippersInput>, Enumerable<ordersUncheckedCreateWithoutShippersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutShippersInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutShippersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutShippersInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutShippersInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type ordersUncheckedUpdateManyWithoutShippersInput = {
    create?: XOR<Enumerable<ordersCreateWithoutShippersInput>, Enumerable<ordersUncheckedCreateWithoutShippersInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutShippersInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutShippersInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutShippersInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutShippersInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type productsCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productsCreateWithoutSupplierInput>, Enumerable<productsUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutSupplierInput>
    connect?: Enumerable<productsWhereUniqueInput>
  }

  export type productsUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productsCreateWithoutSupplierInput>, Enumerable<productsUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutSupplierInput>
    connect?: Enumerable<productsWhereUniqueInput>
  }

  export type productsUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productsCreateWithoutSupplierInput>, Enumerable<productsUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<productsWhereUniqueInput>
    set?: Enumerable<productsWhereUniqueInput>
    disconnect?: Enumerable<productsWhereUniqueInput>
    delete?: Enumerable<productsWhereUniqueInput>
    update?: Enumerable<productsUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<productsUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<productsScalarWhereInput>
  }

  export type productsUncheckedUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productsCreateWithoutSupplierInput>, Enumerable<productsUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productsCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<productsUpsertWithWhereUniqueWithoutSupplierInput>
    connect?: Enumerable<productsWhereUniqueInput>
    set?: Enumerable<productsWhereUniqueInput>
    disconnect?: Enumerable<productsWhereUniqueInput>
    delete?: Enumerable<productsWhereUniqueInput>
    update?: Enumerable<productsUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<productsUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<productsScalarWhereInput>
  }

  export type regionsCreateNestedOneWithoutTerritoriesInput = {
    create?: XOR<regionsCreateWithoutTerritoriesInput, regionsUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: regionsCreateOrConnectWithoutTerritoriesInput
    connect?: regionsWhereUniqueInput
  }

  export type employeeterritoriesCreateNestedManyWithoutTerritoriesInput = {
    create?: XOR<Enumerable<employeeterritoriesCreateWithoutTerritoriesInput>, Enumerable<employeeterritoriesUncheckedCreateWithoutTerritoriesInput>>
    connectOrCreate?: Enumerable<employeeterritoriesCreateOrConnectWithoutTerritoriesInput>
    connect?: Enumerable<employeeterritoriesWhereUniqueInput>
  }

  export type employeeterritoriesUncheckedCreateNestedManyWithoutTerritoriesInput = {
    create?: XOR<Enumerable<employeeterritoriesCreateWithoutTerritoriesInput>, Enumerable<employeeterritoriesUncheckedCreateWithoutTerritoriesInput>>
    connectOrCreate?: Enumerable<employeeterritoriesCreateOrConnectWithoutTerritoriesInput>
    connect?: Enumerable<employeeterritoriesWhereUniqueInput>
  }

  export type regionsUpdateOneWithoutTerritoriesInput = {
    create?: XOR<regionsCreateWithoutTerritoriesInput, regionsUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: regionsCreateOrConnectWithoutTerritoriesInput
    upsert?: regionsUpsertWithoutTerritoriesInput
    connect?: regionsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<regionsUpdateWithoutTerritoriesInput, regionsUncheckedUpdateWithoutTerritoriesInput>
  }

  export type employeeterritoriesUpdateManyWithoutTerritoriesInput = {
    create?: XOR<Enumerable<employeeterritoriesCreateWithoutTerritoriesInput>, Enumerable<employeeterritoriesUncheckedCreateWithoutTerritoriesInput>>
    connectOrCreate?: Enumerable<employeeterritoriesCreateOrConnectWithoutTerritoriesInput>
    upsert?: Enumerable<employeeterritoriesUpsertWithWhereUniqueWithoutTerritoriesInput>
    connect?: Enumerable<employeeterritoriesWhereUniqueInput>
    set?: Enumerable<employeeterritoriesWhereUniqueInput>
    disconnect?: Enumerable<employeeterritoriesWhereUniqueInput>
    delete?: Enumerable<employeeterritoriesWhereUniqueInput>
    update?: Enumerable<employeeterritoriesUpdateWithWhereUniqueWithoutTerritoriesInput>
    updateMany?: Enumerable<employeeterritoriesUpdateManyWithWhereWithoutTerritoriesInput>
    deleteMany?: Enumerable<employeeterritoriesScalarWhereInput>
  }

  export type employeeterritoriesUncheckedUpdateManyWithoutTerritoriesInput = {
    create?: XOR<Enumerable<employeeterritoriesCreateWithoutTerritoriesInput>, Enumerable<employeeterritoriesUncheckedCreateWithoutTerritoriesInput>>
    connectOrCreate?: Enumerable<employeeterritoriesCreateOrConnectWithoutTerritoriesInput>
    upsert?: Enumerable<employeeterritoriesUpsertWithWhereUniqueWithoutTerritoriesInput>
    connect?: Enumerable<employeeterritoriesWhereUniqueInput>
    set?: Enumerable<employeeterritoriesWhereUniqueInput>
    disconnect?: Enumerable<employeeterritoriesWhereUniqueInput>
    delete?: Enumerable<employeeterritoriesWhereUniqueInput>
    update?: Enumerable<employeeterritoriesUpdateWithWhereUniqueWithoutTerritoriesInput>
    updateMany?: Enumerable<employeeterritoriesUpdateManyWithWhereWithoutTerritoriesInput>
    deleteMany?: Enumerable<employeeterritoriesScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type productsCreateWithoutCategoryInput = {
    ProductName?: string | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    supplier?: suppliersCreateNestedOneWithoutProductsInput
    orderdetails?: orderdetailsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutCategoryInput = {
    ProductID?: number
    ProductName?: string | null
    SupplierID?: number | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutCategoryInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutCategoryInput, productsUncheckedCreateWithoutCategoryInput>
  }

  export type productsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutCategoryInput, productsUncheckedUpdateWithoutCategoryInput>
    create: XOR<productsCreateWithoutCategoryInput, productsUncheckedCreateWithoutCategoryInput>
  }

  export type productsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutCategoryInput, productsUncheckedUpdateWithoutCategoryInput>
  }

  export type productsUpdateManyWithWhereWithoutCategoryInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutProducts_categoriesToproducts_CategoryIDInput>
  }

  export type productsScalarWhereInput = {
    AND?: Enumerable<productsScalarWhereInput>
    OR?: Enumerable<productsScalarWhereInput>
    NOT?: Enumerable<productsScalarWhereInput>
    ProductID?: IntFilter | number
    ProductName?: StringNullableFilter | string | null
    SupplierID?: IntNullableFilter | number | null
    CategoryID?: IntNullableFilter | number | null
    QuantityPerUnit?: StringNullableFilter | string | null
    UnitPrice?: DecimalNullableFilter | Decimal | number | string | null
    UnitsInStock?: IntNullableFilter | number | null
    UnitsOnOrder?: IntNullableFilter | number | null
    ReorderLevel?: IntNullableFilter | number | null
    Discontinued?: StringNullableFilter | string | null
  }

  export type customersCreateWithoutCustomercustomerdemoInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    orders?: ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutCustomercustomerdemoInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    orders?: ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutCustomercustomerdemoInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutCustomercustomerdemoInput, customersUncheckedCreateWithoutCustomercustomerdemoInput>
  }

  export type customerdemographicsCreateWithoutCustomercustomerdemoInput = {
    CustomerTypeID: string
    CustomerDesc?: string | null
  }

  export type customerdemographicsUncheckedCreateWithoutCustomercustomerdemoInput = {
    CustomerTypeID: string
    CustomerDesc?: string | null
  }

  export type customerdemographicsCreateOrConnectWithoutCustomercustomerdemoInput = {
    where: customerdemographicsWhereUniqueInput
    create: XOR<customerdemographicsCreateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedCreateWithoutCustomercustomerdemoInput>
  }

  export type customersUpsertWithoutCustomercustomerdemoInput = {
    update: XOR<customersUpdateWithoutCustomercustomerdemoInput, customersUncheckedUpdateWithoutCustomercustomerdemoInput>
    create: XOR<customersCreateWithoutCustomercustomerdemoInput, customersUncheckedCreateWithoutCustomercustomerdemoInput>
  }

  export type customersUpdateWithoutCustomercustomerdemoInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutCustomersInput
  }

  export type customersUncheckedUpdateWithoutCustomercustomerdemoInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutCustomersInput
  }

  export type customerdemographicsUpsertWithoutCustomercustomerdemoInput = {
    update: XOR<customerdemographicsUpdateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedUpdateWithoutCustomercustomerdemoInput>
    create: XOR<customerdemographicsCreateWithoutCustomercustomerdemoInput, customerdemographicsUncheckedCreateWithoutCustomercustomerdemoInput>
  }

  export type customerdemographicsUpdateWithoutCustomercustomerdemoInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerdemographicsUncheckedUpdateWithoutCustomercustomerdemoInput = {
    CustomerTypeID?: StringFieldUpdateOperationsInput | string
    CustomerDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customercustomerdemoCreateWithoutCustomerdemographicsInput = {
    customers: customersCreateNestedOneWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput = {
    CustomerID: string
  }

  export type customercustomerdemoCreateOrConnectWithoutCustomerdemographicsInput = {
    where: customercustomerdemoWhereUniqueInput
    create: XOR<customercustomerdemoCreateWithoutCustomerdemographicsInput, customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>
  }

  export type customercustomerdemoUpsertWithWhereUniqueWithoutCustomerdemographicsInput = {
    where: customercustomerdemoWhereUniqueInput
    update: XOR<customercustomerdemoUpdateWithoutCustomerdemographicsInput, customercustomerdemoUncheckedUpdateWithoutCustomerdemographicsInput>
    create: XOR<customercustomerdemoCreateWithoutCustomerdemographicsInput, customercustomerdemoUncheckedCreateWithoutCustomerdemographicsInput>
  }

  export type customercustomerdemoUpdateWithWhereUniqueWithoutCustomerdemographicsInput = {
    where: customercustomerdemoWhereUniqueInput
    data: XOR<customercustomerdemoUpdateWithoutCustomerdemographicsInput, customercustomerdemoUncheckedUpdateWithoutCustomerdemographicsInput>
  }

  export type customercustomerdemoUpdateManyWithWhereWithoutCustomerdemographicsInput = {
    where: customercustomerdemoScalarWhereInput
    data: XOR<customercustomerdemoUpdateManyMutationInput, customercustomerdemoUncheckedUpdateManyWithoutCustomercustomerdemoInput>
  }

  export type customercustomerdemoScalarWhereInput = {
    AND?: Enumerable<customercustomerdemoScalarWhereInput>
    OR?: Enumerable<customercustomerdemoScalarWhereInput>
    NOT?: Enumerable<customercustomerdemoScalarWhereInput>
    CustomerID?: StringFilter | string
    CustomerTypeID?: StringNullableFilter | string | null
  }

  export type customercustomerdemoCreateWithoutCustomersInput = {
    customerdemographics?: customerdemographicsCreateNestedOneWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedCreateWithoutCustomersInput = {
    CustomerTypeID?: string | null
  }

  export type customercustomerdemoCreateOrConnectWithoutCustomersInput = {
    where: customercustomerdemoWhereUniqueInput
    create: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
  }

  export type ordersCreateWithoutCustomersInput = {
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    employees?: employeesCreateNestedOneWithoutOrdersInput
    shippers?: shippersCreateNestedOneWithoutOrdersInput
    orderdetails?: orderdetailsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutCustomersInput = {
    OrderID?: number
    EmployeeID?: number | null
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    ShipVia?: number | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput>
  }

  export type customercustomerdemoUpsertWithoutCustomersInput = {
    update: XOR<customercustomerdemoUpdateWithoutCustomersInput, customercustomerdemoUncheckedUpdateWithoutCustomersInput>
    create: XOR<customercustomerdemoCreateWithoutCustomersInput, customercustomerdemoUncheckedCreateWithoutCustomersInput>
  }

  export type customercustomerdemoUpdateWithoutCustomersInput = {
    customerdemographics?: customerdemographicsUpdateOneWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedUpdateWithoutCustomersInput = {
    CustomerTypeID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpsertWithWhereUniqueWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutCustomersInput, ordersUncheckedUpdateWithoutCustomersInput>
    create: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutCustomersInput, ordersUncheckedUpdateWithoutCustomersInput>
  }

  export type ordersUpdateManyWithWhereWithoutCustomersInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ordersScalarWhereInput = {
    AND?: Enumerable<ordersScalarWhereInput>
    OR?: Enumerable<ordersScalarWhereInput>
    NOT?: Enumerable<ordersScalarWhereInput>
    OrderID?: IntFilter | number
    CustomerID?: StringFilter | string
    EmployeeID?: IntNullableFilter | number | null
    OrderDate?: DateTimeNullableFilter | Date | string | null
    RequiredDate?: DateTimeNullableFilter | Date | string | null
    ShippedDate?: DateTimeNullableFilter | Date | string | null
    ShipVia?: IntNullableFilter | number | null
    Freight?: DecimalNullableFilter | Decimal | number | string | null
    ShipName?: StringNullableFilter | string | null
    ShipAddress?: StringNullableFilter | string | null
    ShipCity?: StringNullableFilter | string | null
    ShipRegion?: StringNullableFilter | string | null
    ShipPostalCode?: StringNullableFilter | string | null
    ShipCountry?: StringNullableFilter | string | null
  }

  export type employeeterritoriesCreateWithoutEmployeesInput = {
    territories?: territoriesCreateNestedOneWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedCreateWithoutEmployeesInput = {
    TerritoryID?: string | null
  }

  export type employeeterritoriesCreateOrConnectWithoutEmployeesInput = {
    where: employeeterritoriesWhereUniqueInput
    create: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
  }

  export type ordersCreateWithoutEmployeesInput = {
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    customers: customersCreateNestedOneWithoutOrdersInput
    shippers?: shippersCreateNestedOneWithoutOrdersInput
    orderdetails?: orderdetailsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutEmployeesInput = {
    OrderID?: number
    CustomerID: string
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    ShipVia?: number | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutEmployeesInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutEmployeesInput, ordersUncheckedCreateWithoutEmployeesInput>
  }

  export type employeeterritoriesUpsertWithoutEmployeesInput = {
    update: XOR<employeeterritoriesUpdateWithoutEmployeesInput, employeeterritoriesUncheckedUpdateWithoutEmployeesInput>
    create: XOR<employeeterritoriesCreateWithoutEmployeesInput, employeeterritoriesUncheckedCreateWithoutEmployeesInput>
  }

  export type employeeterritoriesUpdateWithoutEmployeesInput = {
    territories?: territoriesUpdateOneWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedUpdateWithoutEmployeesInput = {
    TerritoryID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutEmployeesInput, ordersUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ordersCreateWithoutEmployeesInput, ordersUncheckedCreateWithoutEmployeesInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutEmployeesInput, ordersUncheckedUpdateWithoutEmployeesInput>
  }

  export type ordersUpdateManyWithWhereWithoutEmployeesInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type employeesCreateWithoutEmployeeterritoriesInput = {
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    orders?: ordersCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutEmployeeterritoriesInput = {
    EmployeeID?: number
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutEmployeeterritoriesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutEmployeeterritoriesInput, employeesUncheckedCreateWithoutEmployeeterritoriesInput>
  }

  export type territoriesCreateWithoutEmployeeterritoriesInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    regions?: regionsCreateNestedOneWithoutTerritoriesInput
  }

  export type territoriesUncheckedCreateWithoutEmployeeterritoriesInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    RegionID?: number | null
  }

  export type territoriesCreateOrConnectWithoutEmployeeterritoriesInput = {
    where: territoriesWhereUniqueInput
    create: XOR<territoriesCreateWithoutEmployeeterritoriesInput, territoriesUncheckedCreateWithoutEmployeeterritoriesInput>
  }

  export type employeesUpsertWithoutEmployeeterritoriesInput = {
    update: XOR<employeesUpdateWithoutEmployeeterritoriesInput, employeesUncheckedUpdateWithoutEmployeeterritoriesInput>
    create: XOR<employeesCreateWithoutEmployeeterritoriesInput, employeesUncheckedCreateWithoutEmployeeterritoriesInput>
  }

  export type employeesUpdateWithoutEmployeeterritoriesInput = {
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutEmployeesInput
  }

  export type employeesUncheckedUpdateWithoutEmployeeterritoriesInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutEmployeesInput
  }

  export type territoriesUpsertWithoutEmployeeterritoriesInput = {
    update: XOR<territoriesUpdateWithoutEmployeeterritoriesInput, territoriesUncheckedUpdateWithoutEmployeeterritoriesInput>
    create: XOR<territoriesCreateWithoutEmployeeterritoriesInput, territoriesUncheckedCreateWithoutEmployeeterritoriesInput>
  }

  export type territoriesUpdateWithoutEmployeeterritoriesInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    regions?: regionsUpdateOneWithoutTerritoriesInput
  }

  export type territoriesUncheckedUpdateWithoutEmployeeterritoriesInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    RegionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ordersCreateWithoutOrderdetailsInput = {
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    customers: customersCreateNestedOneWithoutOrdersInput
    employees?: employeesCreateNestedOneWithoutOrdersInput
    shippers?: shippersCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutOrderdetailsInput = {
    OrderID?: number
    CustomerID: string
    EmployeeID?: number | null
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    ShipVia?: number | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
  }

  export type ordersCreateOrConnectWithoutOrderdetailsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutOrderdetailsInput, ordersUncheckedCreateWithoutOrderdetailsInput>
  }

  export type productsCreateWithoutOrderdetailsInput = {
    ProductName?: string | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    category?: categoriesCreateNestedOneWithoutProducts_categoriesToproducts_CategoryIDInput
    supplier?: suppliersCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutOrderdetailsInput = {
    ProductID?: number
    ProductName?: string | null
    SupplierID?: number | null
    CategoryID?: number | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
  }

  export type productsCreateOrConnectWithoutOrderdetailsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutOrderdetailsInput, productsUncheckedCreateWithoutOrderdetailsInput>
  }

  export type ordersUpsertWithoutOrderdetailsInput = {
    update: XOR<ordersUpdateWithoutOrderdetailsInput, ordersUncheckedUpdateWithoutOrderdetailsInput>
    create: XOR<ordersCreateWithoutOrderdetailsInput, ordersUncheckedCreateWithoutOrderdetailsInput>
  }

  export type ordersUpdateWithoutOrderdetailsInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: customersUpdateOneRequiredWithoutOrdersInput
    employees?: employeesUpdateOneWithoutOrdersInput
    shippers?: shippersUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateWithoutOrderdetailsInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    CustomerID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsUpsertWithoutOrderdetailsInput = {
    update: XOR<productsUpdateWithoutOrderdetailsInput, productsUncheckedUpdateWithoutOrderdetailsInput>
    create: XOR<productsCreateWithoutOrderdetailsInput, productsUncheckedCreateWithoutOrderdetailsInput>
  }

  export type productsUpdateWithoutOrderdetailsInput = {
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    category?: categoriesUpdateOneWithoutProducts_categoriesToproducts_CategoryIDInput
    supplier?: suppliersUpdateOneWithoutProductsInput
  }

  export type productsUncheckedUpdateWithoutOrderdetailsInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    SupplierID?: NullableIntFieldUpdateOperationsInput | number | null
    CategoryID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersCreateWithoutOrdersInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    customercustomerdemo?: customercustomerdemoCreateNestedOneWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutOrdersInput = {
    CustomerID: string
    CompanyName: string
    ContactName: string
    ContactTitle: string
    Address: string
    City: string
    Region: string
    PostalCode: string
    Country: string
    Phone: string
    Fax: string
    customercustomerdemo?: customercustomerdemoUncheckedCreateNestedOneWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutOrdersInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
  }

  export type employeesCreateWithoutOrdersInput = {
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    employeeterritories?: employeeterritoriesCreateNestedOneWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutOrdersInput = {
    EmployeeID?: number
    LastName?: string | null
    FirstName?: string | null
    Title?: string | null
    TitleOfCourtesy?: string | null
    BirthDate?: Date | string | null
    HireDate?: Date | string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    HomePhone?: string | null
    Extension?: string | null
    Photo?: Buffer | null
    Notes?: string | null
    ReportsTo?: number | null
    PhotoPath?: string | null
    employeeterritories?: employeeterritoriesUncheckedCreateNestedOneWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutOrdersInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutOrdersInput, employeesUncheckedCreateWithoutOrdersInput>
  }

  export type shippersCreateWithoutOrdersInput = {
    CompanyName?: string | null
    Phone?: string | null
  }

  export type shippersUncheckedCreateWithoutOrdersInput = {
    ShipperID?: number
    CompanyName?: string | null
    Phone?: string | null
  }

  export type shippersCreateOrConnectWithoutOrdersInput = {
    where: shippersWhereUniqueInput
    create: XOR<shippersCreateWithoutOrdersInput, shippersUncheckedCreateWithoutOrdersInput>
  }

  export type orderdetailsCreateWithoutOrdersInput = {
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
    products?: productsCreateNestedOneWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedCreateWithoutOrdersInput = {
    ProductID?: number | null
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
  }

  export type orderdetailsCreateOrConnectWithoutOrdersInput = {
    where: orderdetailsWhereUniqueInput
    create: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
  }

  export type customersUpsertWithoutOrdersInput = {
    update: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
  }

  export type customersUpdateWithoutOrdersInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    customercustomerdemo?: customercustomerdemoUpdateOneWithoutCustomersInput
  }

  export type customersUncheckedUpdateWithoutOrdersInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
    CompanyName?: StringFieldUpdateOperationsInput | string
    ContactName?: StringFieldUpdateOperationsInput | string
    ContactTitle?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    Region?: StringFieldUpdateOperationsInput | string
    PostalCode?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Fax?: StringFieldUpdateOperationsInput | string
    customercustomerdemo?: customercustomerdemoUncheckedUpdateOneWithoutCustomersInput
  }

  export type employeesUpsertWithoutOrdersInput = {
    update: XOR<employeesUpdateWithoutOrdersInput, employeesUncheckedUpdateWithoutOrdersInput>
    create: XOR<employeesCreateWithoutOrdersInput, employeesUncheckedCreateWithoutOrdersInput>
  }

  export type employeesUpdateWithoutOrdersInput = {
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUpdateOneWithoutEmployeesInput
  }

  export type employeesUncheckedUpdateWithoutOrdersInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    TitleOfCourtesy?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    HomePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Extension?: NullableStringFieldUpdateOperationsInput | string | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    ReportsTo?: NullableIntFieldUpdateOperationsInput | number | null
    PhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUncheckedUpdateOneWithoutEmployeesInput
  }

  export type shippersUpsertWithoutOrdersInput = {
    update: XOR<shippersUpdateWithoutOrdersInput, shippersUncheckedUpdateWithoutOrdersInput>
    create: XOR<shippersCreateWithoutOrdersInput, shippersUncheckedCreateWithoutOrdersInput>
  }

  export type shippersUpdateWithoutOrdersInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shippersUncheckedUpdateWithoutOrdersInput = {
    ShipperID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderdetailsUpsertWithoutOrdersInput = {
    update: XOR<orderdetailsUpdateWithoutOrdersInput, orderdetailsUncheckedUpdateWithoutOrdersInput>
    create: XOR<orderdetailsCreateWithoutOrdersInput, orderdetailsUncheckedCreateWithoutOrdersInput>
  }

  export type orderdetailsUpdateWithoutOrdersInput = {
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
    products?: productsUpdateOneWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedUpdateWithoutOrdersInput = {
    ProductID?: NullableIntFieldUpdateOperationsInput | number | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type categoriesCreateWithoutProducts_categoriesToproducts_CategoryIDInput = {
    CategoryID: number
    CategoryName?: string | null
    Description?: string | null
    Picture?: Buffer | null
  }

  export type categoriesUncheckedCreateWithoutProducts_categoriesToproducts_CategoryIDInput = {
    CategoryID: number
    CategoryName?: string | null
    Description?: string | null
    Picture?: Buffer | null
  }

  export type categoriesCreateOrConnectWithoutProducts_categoriesToproducts_CategoryIDInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedCreateWithoutProducts_categoriesToproducts_CategoryIDInput>
  }

  export type suppliersCreateWithoutProductsInput = {
    CompanyName?: string | null
    ContactName?: string | null
    ContactTitle?: string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    Phone?: string | null
    Fax?: string | null
    HomePage?: string | null
  }

  export type suppliersUncheckedCreateWithoutProductsInput = {
    SupplierID?: number
    CompanyName?: string | null
    ContactName?: string | null
    ContactTitle?: string | null
    Address?: string | null
    City?: string | null
    Region?: string | null
    PostalCode?: string | null
    Country?: string | null
    Phone?: string | null
    Fax?: string | null
    HomePage?: string | null
  }

  export type suppliersCreateOrConnectWithoutProductsInput = {
    where: suppliersWhereUniqueInput
    create: XOR<suppliersCreateWithoutProductsInput, suppliersUncheckedCreateWithoutProductsInput>
  }

  export type orderdetailsCreateWithoutProductsInput = {
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
    orders: ordersCreateNestedOneWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedCreateWithoutProductsInput = {
    OrderID: number
    UnitPrice?: Decimal | number | string | null
    Quantity?: number | null
    Discount?: number | null
  }

  export type orderdetailsCreateOrConnectWithoutProductsInput = {
    where: orderdetailsWhereUniqueInput
    create: XOR<orderdetailsCreateWithoutProductsInput, orderdetailsUncheckedCreateWithoutProductsInput>
  }

  export type categoriesUpsertWithoutProducts_categoriesToproducts_CategoryIDInput = {
    update: XOR<categoriesUpdateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedUpdateWithoutProducts_categoriesToproducts_CategoryIDInput>
    create: XOR<categoriesCreateWithoutProducts_categoriesToproducts_CategoryIDInput, categoriesUncheckedCreateWithoutProducts_categoriesToproducts_CategoryIDInput>
  }

  export type categoriesUpdateWithoutProducts_categoriesToproducts_CategoryIDInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type categoriesUncheckedUpdateWithoutProducts_categoriesToproducts_CategoryIDInput = {
    CategoryID?: IntFieldUpdateOperationsInput | number
    CategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Picture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type suppliersUpsertWithoutProductsInput = {
    update: XOR<suppliersUpdateWithoutProductsInput, suppliersUncheckedUpdateWithoutProductsInput>
    create: XOR<suppliersCreateWithoutProductsInput, suppliersUncheckedCreateWithoutProductsInput>
  }

  export type suppliersUpdateWithoutProductsInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type suppliersUncheckedUpdateWithoutProductsInput = {
    SupplierID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactName?: NullableStringFieldUpdateOperationsInput | string | null
    ContactTitle?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    HomePage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderdetailsUpsertWithWhereUniqueWithoutProductsInput = {
    where: orderdetailsWhereUniqueInput
    update: XOR<orderdetailsUpdateWithoutProductsInput, orderdetailsUncheckedUpdateWithoutProductsInput>
    create: XOR<orderdetailsCreateWithoutProductsInput, orderdetailsUncheckedCreateWithoutProductsInput>
  }

  export type orderdetailsUpdateWithWhereUniqueWithoutProductsInput = {
    where: orderdetailsWhereUniqueInput
    data: XOR<orderdetailsUpdateWithoutProductsInput, orderdetailsUncheckedUpdateWithoutProductsInput>
  }

  export type orderdetailsUpdateManyWithWhereWithoutProductsInput = {
    where: orderdetailsScalarWhereInput
    data: XOR<orderdetailsUpdateManyMutationInput, orderdetailsUncheckedUpdateManyWithoutOrderdetailsInput>
  }

  export type orderdetailsScalarWhereInput = {
    AND?: Enumerable<orderdetailsScalarWhereInput>
    OR?: Enumerable<orderdetailsScalarWhereInput>
    NOT?: Enumerable<orderdetailsScalarWhereInput>
    OrderID?: IntFilter | number
    ProductID?: IntNullableFilter | number | null
    UnitPrice?: DecimalNullableFilter | Decimal | number | string | null
    Quantity?: IntNullableFilter | number | null
    Discount?: FloatNullableFilter | number | null
  }

  export type territoriesCreateWithoutRegionsInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    employeeterritories?: employeeterritoriesCreateNestedManyWithoutTerritoriesInput
  }

  export type territoriesUncheckedCreateWithoutRegionsInput = {
    TerritoryID: string
    TerritoryDescription?: string | null
    employeeterritories?: employeeterritoriesUncheckedCreateNestedManyWithoutTerritoriesInput
  }

  export type territoriesCreateOrConnectWithoutRegionsInput = {
    where: territoriesWhereUniqueInput
    create: XOR<territoriesCreateWithoutRegionsInput, territoriesUncheckedCreateWithoutRegionsInput>
  }

  export type territoriesUpsertWithWhereUniqueWithoutRegionsInput = {
    where: territoriesWhereUniqueInput
    update: XOR<territoriesUpdateWithoutRegionsInput, territoriesUncheckedUpdateWithoutRegionsInput>
    create: XOR<territoriesCreateWithoutRegionsInput, territoriesUncheckedCreateWithoutRegionsInput>
  }

  export type territoriesUpdateWithWhereUniqueWithoutRegionsInput = {
    where: territoriesWhereUniqueInput
    data: XOR<territoriesUpdateWithoutRegionsInput, territoriesUncheckedUpdateWithoutRegionsInput>
  }

  export type territoriesUpdateManyWithWhereWithoutRegionsInput = {
    where: territoriesScalarWhereInput
    data: XOR<territoriesUpdateManyMutationInput, territoriesUncheckedUpdateManyWithoutTerritoriesInput>
  }

  export type territoriesScalarWhereInput = {
    AND?: Enumerable<territoriesScalarWhereInput>
    OR?: Enumerable<territoriesScalarWhereInput>
    NOT?: Enumerable<territoriesScalarWhereInput>
    TerritoryID?: StringFilter | string
    TerritoryDescription?: StringNullableFilter | string | null
    RegionID?: IntNullableFilter | number | null
  }

  export type ordersCreateWithoutShippersInput = {
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    customers: customersCreateNestedOneWithoutOrdersInput
    employees?: employeesCreateNestedOneWithoutOrdersInput
    orderdetails?: orderdetailsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutShippersInput = {
    OrderID?: number
    CustomerID: string
    EmployeeID?: number | null
    OrderDate?: Date | string | null
    RequiredDate?: Date | string | null
    ShippedDate?: Date | string | null
    Freight?: Decimal | number | string | null
    ShipName?: string | null
    ShipAddress?: string | null
    ShipCity?: string | null
    ShipRegion?: string | null
    ShipPostalCode?: string | null
    ShipCountry?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutShippersInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutShippersInput, ordersUncheckedCreateWithoutShippersInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutShippersInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutShippersInput, ordersUncheckedUpdateWithoutShippersInput>
    create: XOR<ordersCreateWithoutShippersInput, ordersUncheckedCreateWithoutShippersInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutShippersInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutShippersInput, ordersUncheckedUpdateWithoutShippersInput>
  }

  export type ordersUpdateManyWithWhereWithoutShippersInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type productsCreateWithoutSupplierInput = {
    ProductName?: string | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    category?: categoriesCreateNestedOneWithoutProducts_categoriesToproducts_CategoryIDInput
    orderdetails?: orderdetailsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutSupplierInput = {
    ProductID?: number
    ProductName?: string | null
    CategoryID?: number | null
    QuantityPerUnit?: string | null
    UnitPrice?: Decimal | number | string | null
    UnitsInStock?: number | null
    UnitsOnOrder?: number | null
    ReorderLevel?: number | null
    Discontinued?: string | null
    orderdetails?: orderdetailsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutSupplierInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutSupplierInput, productsUncheckedCreateWithoutSupplierInput>
  }

  export type productsUpsertWithWhereUniqueWithoutSupplierInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutSupplierInput, productsUncheckedUpdateWithoutSupplierInput>
    create: XOR<productsCreateWithoutSupplierInput, productsUncheckedCreateWithoutSupplierInput>
  }

  export type productsUpdateWithWhereUniqueWithoutSupplierInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutSupplierInput, productsUncheckedUpdateWithoutSupplierInput>
  }

  export type productsUpdateManyWithWhereWithoutSupplierInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutProductsInput>
  }

  export type regionsCreateWithoutTerritoriesInput = {
    RegionID: number
    RegionDescription?: string | null
  }

  export type regionsUncheckedCreateWithoutTerritoriesInput = {
    RegionID: number
    RegionDescription?: string | null
  }

  export type regionsCreateOrConnectWithoutTerritoriesInput = {
    where: regionsWhereUniqueInput
    create: XOR<regionsCreateWithoutTerritoriesInput, regionsUncheckedCreateWithoutTerritoriesInput>
  }

  export type employeeterritoriesCreateWithoutTerritoriesInput = {
    employees: employeesCreateNestedOneWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedCreateWithoutTerritoriesInput = {
    EmployeeID: number
  }

  export type employeeterritoriesCreateOrConnectWithoutTerritoriesInput = {
    where: employeeterritoriesWhereUniqueInput
    create: XOR<employeeterritoriesCreateWithoutTerritoriesInput, employeeterritoriesUncheckedCreateWithoutTerritoriesInput>
  }

  export type regionsUpsertWithoutTerritoriesInput = {
    update: XOR<regionsUpdateWithoutTerritoriesInput, regionsUncheckedUpdateWithoutTerritoriesInput>
    create: XOR<regionsCreateWithoutTerritoriesInput, regionsUncheckedCreateWithoutTerritoriesInput>
  }

  export type regionsUpdateWithoutTerritoriesInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type regionsUncheckedUpdateWithoutTerritoriesInput = {
    RegionID?: IntFieldUpdateOperationsInput | number
    RegionDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeterritoriesUpsertWithWhereUniqueWithoutTerritoriesInput = {
    where: employeeterritoriesWhereUniqueInput
    update: XOR<employeeterritoriesUpdateWithoutTerritoriesInput, employeeterritoriesUncheckedUpdateWithoutTerritoriesInput>
    create: XOR<employeeterritoriesCreateWithoutTerritoriesInput, employeeterritoriesUncheckedCreateWithoutTerritoriesInput>
  }

  export type employeeterritoriesUpdateWithWhereUniqueWithoutTerritoriesInput = {
    where: employeeterritoriesWhereUniqueInput
    data: XOR<employeeterritoriesUpdateWithoutTerritoriesInput, employeeterritoriesUncheckedUpdateWithoutTerritoriesInput>
  }

  export type employeeterritoriesUpdateManyWithWhereWithoutTerritoriesInput = {
    where: employeeterritoriesScalarWhereInput
    data: XOR<employeeterritoriesUpdateManyMutationInput, employeeterritoriesUncheckedUpdateManyWithoutEmployeeterritoriesInput>
  }

  export type employeeterritoriesScalarWhereInput = {
    AND?: Enumerable<employeeterritoriesScalarWhereInput>
    OR?: Enumerable<employeeterritoriesScalarWhereInput>
    NOT?: Enumerable<employeeterritoriesScalarWhereInput>
    EmployeeID?: IntFilter | number
    TerritoryID?: StringNullableFilter | string | null
  }

  export type productsUpdateWithoutCategoryInput = {
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: suppliersUpdateOneWithoutProductsInput
    orderdetails?: orderdetailsUpdateManyWithoutProductsInput
  }

  export type productsUncheckedUpdateWithoutCategoryInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    SupplierID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateManyWithoutProductsInput
  }

  export type productsUncheckedUpdateManyWithoutProducts_categoriesToproducts_CategoryIDInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    SupplierID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customercustomerdemoUpdateWithoutCustomerdemographicsInput = {
    customers?: customersUpdateOneRequiredWithoutCustomercustomerdemoInput
  }

  export type customercustomerdemoUncheckedUpdateWithoutCustomerdemographicsInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
  }

  export type customercustomerdemoUncheckedUpdateManyWithoutCustomercustomerdemoInput = {
    CustomerID?: StringFieldUpdateOperationsInput | string
  }

  export type ordersUpdateWithoutCustomersInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: employeesUpdateOneWithoutOrdersInput
    shippers?: shippersUpdateOneWithoutOrdersInput
    orderdetails?: orderdetailsUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateWithoutCustomersInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateManyWithoutOrdersInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpdateWithoutEmployeesInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: customersUpdateOneRequiredWithoutOrdersInput
    shippers?: shippersUpdateOneWithoutOrdersInput
    orderdetails?: orderdetailsUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateWithoutEmployeesInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    CustomerID?: StringFieldUpdateOperationsInput | string
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShipVia?: NullableIntFieldUpdateOperationsInput | number | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateOneWithoutOrdersInput
  }

  export type orderdetailsUpdateWithoutProductsInput = {
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orders?: ordersUpdateOneRequiredWithoutOrderdetailsInput
  }

  export type orderdetailsUncheckedUpdateWithoutProductsInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type orderdetailsUncheckedUpdateManyWithoutOrderdetailsInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type territoriesUpdateWithoutRegionsInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUpdateManyWithoutTerritoriesInput
  }

  export type territoriesUncheckedUpdateWithoutRegionsInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    employeeterritories?: employeeterritoriesUncheckedUpdateManyWithoutTerritoriesInput
  }

  export type territoriesUncheckedUpdateManyWithoutTerritoriesInput = {
    TerritoryID?: StringFieldUpdateOperationsInput | string
    TerritoryDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpdateWithoutShippersInput = {
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: customersUpdateOneRequiredWithoutOrdersInput
    employees?: employeesUpdateOneWithoutOrdersInput
    orderdetails?: orderdetailsUpdateOneWithoutOrdersInput
  }

  export type ordersUncheckedUpdateWithoutShippersInput = {
    OrderID?: IntFieldUpdateOperationsInput | number
    CustomerID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RequiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Freight?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    ShipName?: NullableStringFieldUpdateOperationsInput | string | null
    ShipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCity?: NullableStringFieldUpdateOperationsInput | string | null
    ShipRegion?: NullableStringFieldUpdateOperationsInput | string | null
    ShipPostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    ShipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateOneWithoutOrdersInput
  }

  export type productsUpdateWithoutSupplierInput = {
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    category?: categoriesUpdateOneWithoutProducts_categoriesToproducts_CategoryIDInput
    orderdetails?: orderdetailsUpdateManyWithoutProductsInput
  }

  export type productsUncheckedUpdateWithoutSupplierInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
    orderdetails?: orderdetailsUncheckedUpdateManyWithoutProductsInput
  }

  export type productsUncheckedUpdateManyWithoutProductsInput = {
    ProductID?: IntFieldUpdateOperationsInput | number
    ProductName?: NullableStringFieldUpdateOperationsInput | string | null
    CategoryID?: NullableIntFieldUpdateOperationsInput | number | null
    QuantityPerUnit?: NullableStringFieldUpdateOperationsInput | string | null
    UnitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    UnitsInStock?: NullableIntFieldUpdateOperationsInput | number | null
    UnitsOnOrder?: NullableIntFieldUpdateOperationsInput | number | null
    ReorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    Discontinued?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeterritoriesUpdateWithoutTerritoriesInput = {
    employees?: employeesUpdateOneRequiredWithoutEmployeeterritoriesInput
  }

  export type employeeterritoriesUncheckedUpdateWithoutTerritoriesInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
  }

  export type employeeterritoriesUncheckedUpdateManyWithoutEmployeeterritoriesInput = {
    EmployeeID?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}